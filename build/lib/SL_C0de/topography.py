from spharm import sphericalobject
import numpy as np
from scipy import io
from ocean_function import spherical_ocean_function

class spherical_topo(sphericalobject):
    """
    A class used to represent the topographic grid

    ...

    Attributes
    ----------
        topo_pres : np.array (maxdeg, maxdeg x2)
            The present topography gaussian grid
        topo_initial : np.array (maxdeg, maxdeg x2)
            The topography at the begining of the modelization (maxdeg, maxdeg x2)
        topo : np.array (n_time_step, maxdeg, maxdeg x2)
            The topography threw time
        topo_0 : np.array (maxdeg, maxdeg x2)
            Gaussian grid of the topography at the time of run update_topo_0. Used to save the initial topography after it's modification by the load. 

    Methods
    -------
        load(grid,,ice,sed)
            Load the topographic data from the file topo_SL. Create the topography variation by including the ice thickness and the sediment thickness
        update_topo_0()
            update the topo_0 attribute.
        ice_correction(ice,grid,oc)
            correct the ice and the topography from the land attached ice variation.          

    """
    def __init__(self) : 
        """
        Parameters
        ----------
        """
        # initialize coefficient and grid to 0 because no grid or coefficient has been created
        self.isgrd=False
        self.iscoeff=False
        self.saved=np.array([])
        
    def load(self,SL_model):
        '''
        Load the topography and adapt it with the ice and sediment thickness.
        
        Parameters :  
            grid (object): output of the class GRID
            ice (object): output of the class spherical_ice
            sed (object): output of the class spherical_sed
             
        See the documentation of the cited class object for more information on different parameters used in the function.
        
        Returns :
            
        Added fields : 
            topo_pres (np.array): matrix of the present topography with shape maxdeg, maxdeg x 2. This grid is 
                                  defined to compare with the topography at the end of the simulation.
            topo_initial (np.array): matrix of the topography at the begining of the modelisation, with shape maxdeg, maxdeg x 2.
            topo (np.array):matrix of the topography threw time with shape time step, maxdeg, maxdeg x 2.
            grd (np.array): graussian grid set to the topography at the beginning of the simulation, maxdeg, maxdeg x 2.
        
        '''
        data=io.loadmat('topo_SL') # load the topographic data from topo_SL
        self.topo_pres=SL_model.grid.interp_on(data['topo_bed'],np.transpose(data['lon_topo'][0]),np.transpose(data['lat_topo'][0]))+SL_model.ice.ice[-1,:,:] 
        self.topo_initial=self.topo_pres - SL_model.ice.ice[-1,:,:]-SL_model.sed.sed[0,:,:]+SL_model.ice.ice[0,:,:]
        self.topo=np.zeros((len(SL_model.grid.time_step),SL_model.grid.nlats,SL_model.grid.nlons))
        for i in range(1,len(SL_model.grid.time_step)):
            self.topo[i,:,:]=self.topo_pres - SL_model.ice.ice[0,:,:]-SL_model.sed.sed[i,:,:]+SL_model.ice.ice[i,:,:]
        return self
    
    def update_topo_0(self):
        '''
        update the topography 0 wich is the topography at the beginning of the simulation. This function is used to update
        the initial topography after each simulation to restart a loop over it. This way there is a convergence and we take in account the GIA.
        
        Parameters :  
             
        See the documentation of the cited class object for more information on different parameters used in the function.
        
        Returns :
            
        Added fields : 
            topo_0 (np.array): A matrix of the topography at the bigining of the simulation of shape maxdeg, maxdeg x 2.  
        '''
        self.topo_0=self.topo[0,:,:].copy() # update the actual topography 
        return self
    
    def ice_correction(self,SL_model):
        '''
        A function to correct the variation of crusted ice due to the variation of the topography. 
        This function use the ocean function generated by the ice thickness minus topography, topography minus ice thickness and
        the ice load plus the crusted ice. 
        
        Parameters :  
             
        See the documentation of the cited class object for more information on different parameters used in the function.
        
        Returns :
            
        Added fields : 
            topo (array): the topography matrix threw time with shape time_step, maxdeg, maxdeg x 2.
            ice_corrected (array): the ice corrected from crusted ice matrix of shape time_step, maxdeg, maxdeg x 2
        
        '''
        # apply the correction for each time step
        for t_it in range(len(SL_model.grid.time_step)):
            self.topo[t_it,:,:]=self.topo[t_it,:,:]-SL_model.ice.ice_corrected[t_it,:,:]+SL_model.ice.ice[t_it,:,:]
        for t_it in range(len(SL_model.grid.time_step)): # to parallelize
            check1 = spherical_ocean_function().evaluate_ocean(-self.topo[t_it,:,:]+SL_model.ice.ice[t_it,:,:]) # generate the ocean function for ice-topo
            check2 = spherical_ocean_function().evaluate_ocean(self.topo[t_it,:,:]-SL_model.ice.ice[t_it,:,:]).grd*(spherical_ocean_function().evaluate_ocean(-SL_model.ice.ice[t_it,:,:]*SL_model.ice.rho-(self.topo[t_it,:,:]-SL_model.ice.ice[t_it,:,:])*SL_model.oc.rho).grd)
            SL_model.ice.ice_corrected[t_it,:,:] = check1.grd*SL_model.ice.ice[t_it,:,:]+check2*SL_model.ice.ice[t_it,:,:] # add the two part of ice over the check1 nd check2 positive area.
        for t_it in range(len(SL_model.grid.time_step)):    
            self.topo[t_it,:,:]=self.topo[t_it,:,:]+SL_model.ice.ice_corrected[t_it,:,:]-SL_model.ice.ice[t_it,:,:]
         # apply the correction to the topography.
            #plt.pcolor(self.topo[t_it,:,:])
            #plt.colorbar()
            #plt.show() 