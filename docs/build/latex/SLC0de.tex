%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Sonny]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}

\renewcommand{\hyperref}[2][]{(#2 p.\pageref{#1})}

\title{SL$_{C0de}$ Documentation}
\date{Nov 15, 2023}
\release{0.4.0}
\author{Adrien Henry}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{\protect\(SL_{C0de}\protect\)}
\label{\detokenize{index:sl-c0de}}
\noindent\sphinxincludegraphics{{Bengal_Bay}.pdf}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This project is under active development.
\end{sphinxadmonition}

\sphinxAtStartPar
\(SL_{C0de}\) is a python library based on the theory described in {[}\hyperlink{cite.index:id3}{Dalca \sphinxstyleemphasis{et al.}, 2013}{]}. This module provides tools to resolve the Sea Level Equation (SLE). This theory incorporates the governing equations, shoreline migration due to local sea level variation and changes in the geometry of grounded/marine based ice. This theory is based on Love numbers theory, which include gravitational, deformational and rotational effects of the sediment redistribution.

\sphinxstepscope


\section{Usage}
\label{\detokenize{usage:usage}}\label{\detokenize{usage::doc}}

\subsection{INSTALLATION}
\label{\detokenize{usage:installation}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The code is developped on windows for the moment. We want to export it on other OS but for the moment we focus on the packages.
\end{sphinxadmonition}

\sphinxAtStartPar
Download

\sphinxAtStartPar
To install the library, run in command line :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(.venv) \PYGZdl{} conda create \PYGZhy{}n SL\PYGZus{}C0de
(.venv) \PYGZdl{} conda activate SL\PYGZus{}C0de
(.venv) \PYGZdl{} conda install pip
(.venv) \PYGZdl{} pip install \PYGZhy{}\PYGZhy{}index\PYGZhy{}url https://test.pypi.org/simple/ \PYGZhy{}\PYGZhy{}no\PYGZhy{}deps slcode
\end{sphinxVerbatim}

\sphinxAtStartPar
To install the dependencies, download the requirements.txt on \sphinxurl{https://github.com/AHenryLarroze/Py\_SL\_C0de} and run inside the file :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(.venv) \PYGZdl{} pip install \PYGZhy{}r requirements
\end{sphinxVerbatim}

\sphinxAtStartPar
You also need the stripy package. This package has unstable deployment. Try to install this package with pip and conda.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
You need to be in the activated environment to install the packages locally
\end{sphinxadmonition}

\sphinxAtStartPar
For testing the module. You can download the script file in \sphinxurl{https://github.com/AHenryLarroze/Py\_SL\_C0de}. You will also need cartopy to install it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
(.venv) \PYGZdl{} conda install \PYGZhy{}c conda\PYGZhy{}forge cartopy
\end{sphinxVerbatim}


\subsection{\protect\(SL_{C0de}\protect\) minimal exemple}
\label{\detokenize{usage:sl-c0de-minimal-exemple}}
\sphinxAtStartPar
Here we propose to run the code over 26 kyr with a time resolution of 500 years. The spatial resolution is deduced from the maximum spherical harmonic degree (see section xx). Here 64 degree correspond to a spatial resolution of 170 km at the equator.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{stop}\PYG{o}{=}\PYG{l+m+mi}{26} \PYG{c+c1}{\PYGZsh{}stop the computation at 26 kyr}
\PYG{n}{step}\PYG{o}{=}\PYG{l+m+mf}{0.5} \PYG{c+c1}{\PYGZsh{} run the model at a time resolution of 0.5}
\PYG{n}{time\PYGZus{}step}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{start}\PYG{o}{=}\PYG{n}{stop}\PYG{p}{,}\PYG{n}{stop}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{step}\PYG{p}{,}\PYG{n}{step}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n}{step}\PYG{p}{)}
\PYG{n}{maxdeg}\PYG{o}{=}\PYG{l+m+mi}{64} \PYG{c+c1}{\PYGZsh{}Define the maximum degrre of spherical harmonics}
\end{sphinxVerbatim}

\sphinxAtStartPar
We preset the ice, sediment and topographic time grid.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{SL\PYGZus{}C0de}\PYG{n+nn}{.}\PYG{n+nn}{grid} \PYG{k+kn}{import} \PYG{n}{ICE\PYGZus{}TIME\PYGZus{}GRID}
\PYG{k+kn}{from} \PYG{n+nn}{SL\PYGZus{}C0de}\PYG{n+nn}{.}\PYG{n+nn}{grid} \PYG{k+kn}{import} \PYG{n}{SEDIMENT\PYGZus{}TIME\PYGZus{}GRID}
\PYG{k+kn}{from} \PYG{n+nn}{SL\PYGZus{}C0de}\PYG{n+nn}{.}\PYG{n+nn}{grid} \PYG{k+kn}{import} \PYG{n}{TOPOGRAPHIC\PYGZus{}TIME\PYGZus{}GRID}

\PYG{n}{ice\PYGZus{}time\PYGZus{}grid}\PYG{o}{=}\PYG{n}{ICE\PYGZus{}TIME\PYGZus{}GRID}\PYG{p}{(}\PYG{n}{time\PYGZus{}step}\PYG{p}{,}\PYG{n}{maxdeg}\PYG{p}{,}\PYG{n}{grid\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ice}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{sed\PYGZus{}time\PYGZus{}grid}\PYG{o}{=}\PYG{n}{SEDIMENT\PYGZus{}TIME\PYGZus{}GRID}\PYG{p}{(}\PYG{n}{time\PYGZus{}step}\PYG{p}{,}\PYG{n}{maxdeg}\PYG{p}{,}\PYG{n}{grid\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{topo\PYGZus{}time\PYGZus{}grid}\PYG{o}{=}\PYG{n}{TOPOGRAPHIC\PYGZus{}TIME\PYGZus{}GRID}\PYG{p}{(}\PYG{n}{time\PYGZus{}step}\PYG{p}{,}\PYG{n}{maxdeg}\PYG{p}{,}\PYG{n}{grid\PYGZus{}name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{topo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
For this example we will set no ice load, with the method zeros\_time. topography have a general depth of 3000 m. We create a disk centered at the equator with a thickness of 100 m, a radius of 300 km and deposited after 500 years.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sed\PYGZus{}time\PYGZus{}grid}\PYG{o}{.}\PYG{n}{disk\PYGZus{}time}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{180}\PYG{p}{,}\PYG{l+m+mf}{1.5}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{p}{:}
\PYG{n}{ice\PYGZus{}time\PYGZus{}grid}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}time}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{ice\PYGZus{}time\PYGZus{}grid}\PYG{o}{.}\PYG{n}{time\PYGZus{}step\PYGZus{}number}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{topo\PYGZus{}time\PYGZus{}grid}\PYG{o}{.}\PYG{n}{zeros\PYGZus{}time}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{topo\PYGZus{}time\PYGZus{}grid}\PYG{o}{.}\PYG{n}{time\PYGZus{}step\PYGZus{}number}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{topo\PYGZus{}time\PYGZus{}grid}\PYG{o}{.}\PYG{n}{height\PYGZus{}time\PYGZus{}grid}\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{l+m+mi}{3000}
\PYG{n}{topo\PYGZus{}time\PYGZus{}grid}\PYG{o}{.}\PYG{n}{topo\PYGZus{}pres}\PYG{o}{=}\PYG{n}{topo\PYGZus{}time\PYGZus{}grid}\PYG{o}{.}\PYG{n}{height\PYGZus{}time\PYGZus{}grid}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}
\PYG{n}{topo\PYGZus{}time\PYGZus{}grid}\PYG{o}{.}\PYG{n}{topo\PYGZus{}initial}\PYG{o}{=}\PYG{n}{topo\PYGZus{}time\PYGZus{}grid}\PYG{o}{.}\PYG{n}{height\PYGZus{}time\PYGZus{}grid}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now all entries are set up, we can resolve the sea level equation. We set as entry love numbers based on VM5 {[}\hyperlink{cite.index:id11}{Peltier \sphinxstyleemphasis{et al.}, 2015}{]} with a litosphere of 60 km, a upper mantle viscosity of \(10^{20.5}\) Pa.s and a lower mantle viscosity of \(10^{22.699}\) Pa.s. We use a forward modeling version of the SLE resolution. We set a convergence criterion of the SLE to \(10^{-10}\)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{SL\PYGZus{}C0de}\PYG{n+nn}{.}\PYG{n+nn}{SOLVER} \PYG{k+kn}{import} \PYG{n}{SLE\PYGZus{}forward\PYGZus{}modeling}

\PYG{n}{love\PYGZus{}file}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{VM5a.l60.um20.5.lm22.699}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{love\PYGZus{}way}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{input\PYGZus{}data/love/}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{conv\PYGZus{}lim}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{o}{\PYGZca{}}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{n}{ocean\PYGZus{}time\PYGZus{}grid}\PYG{p}{,}\PYG{n}{ice\PYGZus{}time\PYGZus{}grid\PYGZus{}model}\PYG{p}{,}\PYG{n}{topo\PYGZus{}time\PYGZus{}grid\PYGZus{}model}\PYG{o}{=}\PYG{n}{SLE\PYGZus{}forward\PYGZus{}modeling}\PYG{p}{(}\PYG{n}{ice\PYGZus{}time\PYGZus{}grid}\PYG{p}{,}\PYG{n}{sed\PYGZus{}time\PYGZus{}grid}\PYG{p}{,}\PYG{n}{topo\PYGZus{}time\PYGZus{}grid}\PYG{p}{,}\PYG{n}{love\PYGZus{}way}\PYG{p}{,}\PYG{n}{love\PYGZus{}file}\PYG{p}{,}\PYG{n}{conv\PYGZus{}lim}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
From here, we can post process these data to compute subsidence linked to the different loads. First you must save your result into a file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{sys}

\PYG{n}{Output\PYGZus{}way}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{outputs/}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{k}{if} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{Output\PYGZus{}way}\PYG{o}{+}\PYG{n}{love\PYGZus{}file}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{os}\PYG{o}{.}\PYG{n}{mkdir}\PYG{p}{(}\PYG{n}{Output\PYGZus{}way}\PYG{o}{+}\PYG{n}{love\PYGZus{}file}\PYG{p}{)}
\PYG{n}{ocean\PYGZus{}time\PYGZus{}grid}\PYG{o}{.}\PYG{n}{timecoefftotimegrd}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ocean\PYGZus{}time\PYGZus{}grid}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{Output\PYGZus{}way}\PYG{o}{+}\PYG{n}{love\PYGZus{}file}\PYG{p}{)}
\PYG{n}{ice\PYGZus{}time\PYGZus{}grid\PYGZus{}model}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{Output\PYGZus{}way}\PYG{o}{+}\PYG{n}{love\PYGZus{}file}\PYG{p}{)}
\PYG{n}{topo\PYGZus{}time\PYGZus{}grid\PYGZus{}model}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{Output\PYGZus{}way}\PYG{o}{+}\PYG{n}{love\PYGZus{}file}\PYG{p}{)}
\PYG{n}{sediment\PYGZus{}time\PYGZus{}grid}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{n}{Output\PYGZus{}way}\PYG{o}{+}\PYG{n}{love\PYGZus{}file}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Now we apply the post process

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{SL\PYGZus{}C0de}\PYG{n+nn}{.}\PYG{n+nn}{SOLVER} \PYG{k+kn}{import} \PYG{n}{Post\PYGZus{}process}

\PYG{n}{Input\PYGZus{}way\PYGZus{}sed}\PYG{o}{=}\PYG{n}{Output\PYGZus{}way}\PYG{o}{+}\PYG{n}{love\PYGZus{}file}
\PYG{n}{Input\PYGZus{}way\PYGZus{}model\PYGZus{}output}\PYG{o}{=}\PYG{n}{Output\PYGZus{}way}
\PYG{n}{Post\PYGZus{}process}\PYG{p}{(}\PYG{n}{Input\PYGZus{}way\PYGZus{}sed}\PYG{p}{,}\PYG{n}{Input\PYGZus{}way\PYGZus{}model\PYGZus{}output}\PYG{p}{,}\PYG{n}{love\PYGZus{}way}\PYG{p}{)}\PYG{p}{:}
\end{sphinxVerbatim}

\sphinxAtStartPar
Post process create new files in a folder called LOAD in the output folder. These data can be plotted using different functions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{SL\PYGZus{}C0de}\PYG{n+nn}{.}\PYG{n+nn}{grid} \PYG{k+kn}{import} \PYG{n}{LOAD\PYGZus{}TIME\PYGZus{}GRID}
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{n}{sediment\PYGZus{}color}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{sediment\PYGZus{}color\PYGZus{}dark}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{l+m+mf}{0.25}\PYG{p}{)}
\PYG{n}{ice\PYGZus{}color}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{l+m+mf}{0.8}\PYG{p}{,}\PYG{l+m+mf}{0.8}\PYG{p}{)}
\PYG{n}{ocean\PYGZus{}color}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{l+m+mf}{0.6}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{extract\PYGZus{}local\PYGZus{}map}\PYG{p}{(}\PYG{n}{way}\PYG{p}{,}\PYG{n}{shot}\PYG{p}{,}\PYG{n}{res}\PYG{p}{,}\PYG{n}{time}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{load}\PYG{o}{=}\PYG{n}{LOAD\PYGZus{}TIME\PYGZus{}GRID}\PYG{p}{(}\PYG{n}{from\PYGZus{}file}\PYG{o}{=}\PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{way}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/LOAD/SEDIMENT\PYGZus{}LOAD\PYGZus{}122\PYGZus{}512}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{load}\PYG{o}{.}\PYG{n}{height\PYGZus{}time\PYGZus{}coeff}\PYG{o}{=}\PYG{n}{load}\PYG{o}{.}\PYG{n}{viscuous\PYGZus{}deformation}\PYG{o}{+}\PYG{n}{load}\PYG{o}{.}\PYG{n}{elastic\PYGZus{}deformation}
    \PYG{n}{t\PYGZus{}it}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{where}\PYG{p}{(}\PYG{n}{load}\PYG{o}{.}\PYG{n}{time\PYGZus{}step}\PYG{o}{==}\PYG{n}{time}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{n}{load}\PYG{o}{.}\PYG{n}{coeff}\PYG{o}{=}\PYG{p}{(}\PYG{n}{load}\PYG{o}{.}\PYG{n}{coeff\PYGZus{}from\PYGZus{}step}\PYG{p}{(}\PYG{n}{t\PYGZus{}it}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{coeff}\PYG{o}{\PYGZhy{}}\PYG{n}{load}\PYG{o}{.}\PYG{n}{coeff\PYGZus{}from\PYGZus{}step}\PYG{p}{(}\PYG{n}{t\PYGZus{}it}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{.}\PYG{n}{coeff}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{load}\PYG{o}{.}\PYG{n}{time\PYGZus{}step}\PYG{p}{[}\PYG{n}{t\PYGZus{}it}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{load}\PYG{o}{.}\PYG{n}{time\PYGZus{}step}\PYG{p}{[}\PYG{n}{t\PYGZus{}it}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{grid}\PYG{p}{,}\PYG{n}{lon\PYGZus{}hd}\PYG{p}{,}\PYG{n}{lat\PYGZus{}hd}\PYG{o}{=}\PYG{n}{load}\PYG{o}{.}\PYG{n}{coefftogrdhd}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}
    \PYG{n}{lon\PYGZus{}lim\PYGZus{}min}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{lon\PYGZus{}hd}\PYG{o}{\PYGZhy{}}\PYG{n}{shot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{argmin}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{lon\PYGZus{}lim\PYGZus{}max}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{lon\PYGZus{}hd}\PYG{o}{\PYGZhy{}}\PYG{n}{shot}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{argmin}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{lat\PYGZus{}lim\PYGZus{}min}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{lat\PYGZus{}hd}\PYG{o}{\PYGZhy{}}\PYG{n}{shot}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{argmin}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{lat\PYGZus{}lim\PYGZus{}max}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{lat\PYGZus{}hd}\PYG{o}{\PYGZhy{}}\PYG{n}{shot}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{argmin}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{lon}\PYG{o}{=}\PYG{n}{lon\PYGZus{}hd}\PYG{p}{[}\PYG{n}{lon\PYGZus{}lim\PYGZus{}min}\PYG{p}{:}\PYG{n}{lon\PYGZus{}lim\PYGZus{}max}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{lat}\PYG{o}{=}\PYG{n}{lat\PYGZus{}hd}\PYG{p}{[}\PYG{n}{lat\PYGZus{}lim\PYGZus{}min}\PYG{p}{:}\PYG{n}{lat\PYGZus{}lim\PYGZus{}max}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{grid\PYGZus{}sediment}\PYG{o}{=}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{lat\PYGZus{}lim\PYGZus{}min}\PYG{p}{:}\PYG{n}{lat\PYGZus{}lim\PYGZus{}max}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{lon\PYGZus{}lim\PYGZus{}min}\PYG{p}{:}\PYG{n}{lon\PYGZus{}lim\PYGZus{}max}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}


    \PYG{c+c1}{\PYGZsh{}import ocean\PYGZus{}load}
    \PYG{n}{load}\PYG{o}{=}\PYG{n}{LOAD\PYGZus{}TIME\PYGZus{}GRID}\PYG{p}{(}\PYG{n}{from\PYGZus{}file}\PYG{o}{=}\PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{way}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/LOAD/OCEAN\PYGZus{}LOAD\PYGZus{}122\PYGZus{}512}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{load}\PYG{o}{.}\PYG{n}{height\PYGZus{}time\PYGZus{}coeff}\PYG{o}{=}\PYG{n}{load}\PYG{o}{.}\PYG{n}{viscuous\PYGZus{}deformation}\PYG{o}{+}\PYG{n}{load}\PYG{o}{.}\PYG{n}{elastic\PYGZus{}deformation}
    \PYG{n}{load}\PYG{o}{.}\PYG{n}{coeff}\PYG{o}{=}\PYG{p}{(}\PYG{n}{load}\PYG{o}{.}\PYG{n}{coeff\PYGZus{}from\PYGZus{}step}\PYG{p}{(}\PYG{n}{t\PYGZus{}it}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{coeff}\PYG{o}{\PYGZhy{}}\PYG{n}{load}\PYG{o}{.}\PYG{n}{coeff\PYGZus{}from\PYGZus{}step}\PYG{p}{(}\PYG{n}{t\PYGZus{}it}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{.}\PYG{n}{coeff}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{load}\PYG{o}{.}\PYG{n}{time\PYGZus{}step}\PYG{p}{[}\PYG{n}{t\PYGZus{}it}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{load}\PYG{o}{.}\PYG{n}{time\PYGZus{}step}\PYG{p}{[}\PYG{n}{t\PYGZus{}it}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{grid}\PYG{p}{,}\PYG{n}{lon\PYGZus{}hd}\PYG{p}{,}\PYG{n}{lat\PYGZus{}hd}\PYG{o}{=}\PYG{n}{load}\PYG{o}{.}\PYG{n}{coefftogrdhd}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}
    \PYG{n}{grid\PYGZus{}ocean}\PYG{o}{=}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{lat\PYGZus{}lim\PYGZus{}min}\PYG{p}{:}\PYG{n}{lat\PYGZus{}lim\PYGZus{}max}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{lon\PYGZus{}lim\PYGZus{}min}\PYG{p}{:}\PYG{n}{lon\PYGZus{}lim\PYGZus{}max}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{}import ice\PYGZus{}load}
    \PYG{n}{load}\PYG{o}{=}\PYG{n}{LOAD\PYGZus{}TIME\PYGZus{}GRID}\PYG{p}{(}\PYG{n}{from\PYGZus{}file}\PYG{o}{=}\PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{way}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/LOAD/ICE\PYGZus{}LOAD\PYGZus{}122\PYGZus{}512}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{load}\PYG{o}{.}\PYG{n}{height\PYGZus{}time\PYGZus{}coeff}\PYG{o}{=}\PYG{n}{load}\PYG{o}{.}\PYG{n}{viscuous\PYGZus{}deformation}\PYG{o}{+}\PYG{n}{load}\PYG{o}{.}\PYG{n}{elastic\PYGZus{}deformation}
    \PYG{n}{load}\PYG{o}{.}\PYG{n}{coeff}\PYG{o}{=}\PYG{p}{(}\PYG{n}{load}\PYG{o}{.}\PYG{n}{coeff\PYGZus{}from\PYGZus{}step}\PYG{p}{(}\PYG{n}{t\PYGZus{}it}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{coeff}\PYG{o}{\PYGZhy{}}\PYG{n}{load}\PYG{o}{.}\PYG{n}{coeff\PYGZus{}from\PYGZus{}step}\PYG{p}{(}\PYG{n}{t\PYGZus{}it}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{.}\PYG{n}{coeff}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{load}\PYG{o}{.}\PYG{n}{time\PYGZus{}step}\PYG{p}{[}\PYG{n}{t\PYGZus{}it}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{load}\PYG{o}{.}\PYG{n}{time\PYGZus{}step}\PYG{p}{[}\PYG{n}{t\PYGZus{}it}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{grid}\PYG{p}{,}\PYG{n}{lon\PYGZus{}hd}\PYG{p}{,}\PYG{n}{lat\PYGZus{}hd}\PYG{o}{=}\PYG{n}{load}\PYG{o}{.}\PYG{n}{coefftogrdhd}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}
    \PYG{n}{grid\PYGZus{}ice}\PYG{o}{=}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{lat\PYGZus{}lim\PYGZus{}min}\PYG{p}{:}\PYG{n}{lat\PYGZus{}lim\PYGZus{}max}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{lon\PYGZus{}lim\PYGZus{}min}\PYG{p}{:}\PYG{n}{lon\PYGZus{}lim\PYGZus{}max}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{}import oceanic\PYGZus{}sediment\PYGZus{}load}
    \PYG{n}{load}\PYG{o}{=}\PYG{n}{LOAD\PYGZus{}TIME\PYGZus{}GRID}\PYG{p}{(}\PYG{n}{from\PYGZus{}file}\PYG{o}{=}\PYG{p}{(}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{way}\PYG{o}{+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/LOAD/OCEANIC\PYGZus{}SEDIMENT\PYGZus{}LOAD\PYGZus{}122\PYGZus{}512}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{load}\PYG{o}{.}\PYG{n}{height\PYGZus{}time\PYGZus{}coeff}\PYG{o}{=}\PYG{n}{load}\PYG{o}{.}\PYG{n}{viscuous\PYGZus{}deformation}\PYG{o}{+}\PYG{n}{load}\PYG{o}{.}\PYG{n}{elastic\PYGZus{}deformation}
    \PYG{n}{load}\PYG{o}{.}\PYG{n}{coeff}\PYG{o}{=}\PYG{p}{(}\PYG{n}{load}\PYG{o}{.}\PYG{n}{coeff\PYGZus{}from\PYGZus{}step}\PYG{p}{(}\PYG{n}{t\PYGZus{}it}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{.}\PYG{n}{coeff}\PYG{o}{\PYGZhy{}}\PYG{n}{load}\PYG{o}{.}\PYG{n}{coeff\PYGZus{}from\PYGZus{}step}\PYG{p}{(}\PYG{n}{t\PYGZus{}it}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{.}\PYG{n}{coeff}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{load}\PYG{o}{.}\PYG{n}{time\PYGZus{}step}\PYG{p}{[}\PYG{n}{t\PYGZus{}it}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{load}\PYG{o}{.}\PYG{n}{time\PYGZus{}step}\PYG{p}{[}\PYG{n}{t\PYGZus{}it}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{grid}\PYG{p}{,}\PYG{n}{lon\PYGZus{}hd}\PYG{p}{,}\PYG{n}{lat\PYGZus{}hd}\PYG{o}{=}\PYG{n}{load}\PYG{o}{.}\PYG{n}{coefftogrdhd}\PYG{p}{(}\PYG{n}{res}\PYG{p}{)}
    \PYG{n}{grid\PYGZus{}oceanic\PYGZus{}sediment}\PYG{o}{=}\PYG{n}{grid}\PYG{p}{[}\PYG{n}{lat\PYGZus{}lim\PYGZus{}min}\PYG{p}{:}\PYG{n}{lat\PYGZus{}lim\PYGZus{}max}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{lon\PYGZus{}lim\PYGZus{}min}\PYG{p}{:}\PYG{n}{lon\PYGZus{}lim\PYGZus{}max}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}

    \PYG{k}{return} \PYG{p}{(}\PYG{n}{grid\PYGZus{}sediment}\PYG{p}{,} \PYG{n}{grid\PYGZus{}ocean}\PYG{p}{,} \PYG{n}{grid\PYGZus{}ice}\PYG{p}{,} \PYG{n}{grid\PYGZus{}oceanic\PYGZus{}sediment}\PYG{p}{)}\PYG{p}{,} \PYG{n}{lon}\PYG{p}{,}\PYG{n}{lat}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{n}{Input\PYGZus{}way}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{output/}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{earth\PYGZus{}model\PYGZus{}name\PYGZus{}list}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{listdir}\PYG{p}{(}\PYG{n}{Input\PYGZus{}way}\PYG{p}{)}
\PYG{n}{area} \PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{150}\PYG{p}{,}\PYG{l+m+mi}{210}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{30}\PYG{p}{)}
\PYG{n}{L}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}
\PYG{n}{res}\PYG{o}{=}\PYG{l+m+mi}{1024}
\PYG{n}{time}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{k}{for} \PYG{n}{earth\PYGZus{}model\PYGZus{}name} \PYG{o+ow}{in} \PYG{n}{earth\PYGZus{}model\PYGZus{}name\PYGZus{}list}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{preparing map for earth model : }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{earth\PYGZus{}model\PYGZus{}name}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{out}\PYG{o}{=}\PYG{n}{extract\PYGZus{}local\PYGZus{}map}\PYG{p}{(}\PYG{n}{Input\PYGZus{}way}\PYG{o}{+}\PYG{n}{earth\PYGZus{}model\PYGZus{}name}\PYG{p}{,}\PYG{n}{area}\PYG{p}{,}\PYG{n}{res}\PYG{p}{,}\PYG{n}{time}\PYG{p}{)}
    \PYG{n}{L}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{out}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{lat}\PYG{o}{=}\PYG{n}{out}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
    \PYG{n}{lon}\PYG{o}{=}\PYG{n}{out}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{cartopy}
\PYG{k+kn}{import} \PYG{n+nn}{cartopy}\PYG{n+nn}{.}\PYG{n+nn}{crs} \PYG{k}{as} \PYG{n+nn}{ccrs}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{cm}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{colors} \PYG{k}{as} \PYG{n+nn}{colors}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}


\PYG{n}{font} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{family}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Times New Roman}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{weight}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{normal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
        \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{size}\PYG{l+s+s1}{\PYGZsq{}}   \PYG{p}{:} \PYG{l+m+mi}{12}\PYG{p}{\PYGZcb{}}

\PYG{n}{matplotlib}\PYG{o}{.}\PYG{n}{rc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{font}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{font}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{mapplot}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{,}\PYG{n}{lat}\PYG{p}{,}\PYG{n}{grid}\PYG{p}{,}\PYG{n}{area}\PYG{p}{,}\PYG{n}{name}\PYG{p}{,}\PYG{n}{sup\PYGZus{}name}\PYG{p}{,}\PYG{n}{save\PYGZus{}way}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}\PYG{n}{add\PYGZus{}contour}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}\PYG{n}{contour}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{alpha\PYGZus{}ocean}\PYG{o}{=}\PYG{l+m+mi}{0}
    \PYG{n}{coast\PYGZus{}line\PYGZus{}width}\PYG{o}{=}\PYG{l+m+mf}{0.5}
    \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cm}\PYG{o}{.}\PYG{n}{get\PYGZus{}cmap}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bwr}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{)}
    \PYG{k}{if} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{color} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{cmap}\PYG{o}{=}\PYG{k+kc}{None}

    \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{,} \PYG{n}{facecolor}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{none}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{norm} \PYG{o}{=} \PYG{n}{colors}\PYG{o}{.}\PYG{n}{TwoSlopeNorm}\PYG{p}{(}\PYG{n}{vmin}\PYG{o}{=}\PYG{n}{vmin}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{n}{vmax}\PYG{p}{,}\PYG{n}{vcenter}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{ax1}  \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplot}\PYG{p}{(}\PYG{l+m+mi}{111}\PYG{p}{,} \PYG{n}{projection}\PYG{o}{=}\PYG{n}{ccrs}\PYG{o}{.}\PYG{n}{PlateCarree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{ax1}\PYG{o}{.}\PYG{n}{set\PYGZus{}extent}\PYG{p}{(}\PYG{n}{area}\PYG{p}{)}
    \PYG{n}{m2} \PYG{o}{=} \PYG{n}{ax1}\PYG{o}{.}\PYG{n}{contourf}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{,}\PYG{n}{lon}\PYG{p}{,}\PYG{n}{grid}\PYG{p}{,}\PYG{n}{levels}\PYG{o}{=}\PYG{n}{contour}\PYG{p}{,}\PYG{n}{origin}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lower}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{transform}\PYG{o}{=}\PYG{n}{ccrs}\PYG{o}{.}\PYG{n}{PlateCarree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{extent}\PYG{o}{=}\PYG{n}{area}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{cmap}\PYG{o}{=}\PYG{n}{cmap}\PYG{p}{,}\PYG{n}{colors}\PYG{o}{=}\PYG{n}{color}\PYG{p}{,} \PYG{n}{interpolation}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{gaussian}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{norm}\PYG{o}{=}\PYG{n}{norm}\PYG{p}{)}
    \PYG{k}{if} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{add\PYGZus{}contour} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{CS}\PYG{o}{=}\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{contour}\PYG{p}{(}\PYG{n}{lat}\PYG{p}{,}\PYG{n}{lon}\PYG{p}{,}\PYG{n}{add\PYGZus{}contour}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{colors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{linewidths}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{linestyles}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{solid}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{ax1}\PYG{o}{.}\PYG{n}{clabel}\PYG{p}{(}\PYG{n}{CS}\PYG{p}{,} \PYG{n}{CS}\PYG{o}{.}\PYG{n}{levels}\PYG{p}{,} \PYG{n}{inline}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{fontsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}

    \PYG{n}{cbar2}\PYG{o}{=}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{colorbar}\PYG{p}{(}\PYG{n}{mappable}\PYG{o}{=}\PYG{n}{m2}\PYG{p}{,} \PYG{n}{orientation}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{horizontal}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{shrink}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
    \PYG{n}{cbar2}\PYG{o}{.}\PYG{n}{set\PYGZus{}label}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Total\PYGZus{}subsidence (m) fro }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{name}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{k}{if} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{contour} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{cbar2}\PYG{o}{.}\PYG{n}{set\PYGZus{}ticks}\PYG{p}{(}\PYG{n}{contour}\PYG{p}{)}
    \PYG{k}{elif} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{vmax} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{)} \PYG{o+ow}{and} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{vmin} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{cbar2}\PYG{o}{.}\PYG{n}{set\PYGZus{}ticks}\PYG{p}{(}\PYG{p}{[}\PYG{n}{vmin}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{elif} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{vmin} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{cbar2}\PYG{o}{.}\PYG{n}{set\PYGZus{}ticks}\PYG{p}{(}\PYG{p}{[}\PYG{n}{vmin}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{elif} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{vmax} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{cbar2}\PYG{o}{.}\PYG{n}{set\PYGZus{}ticks}\PYG{p}{(}\PYG{p}{[}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{vmax}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{else}\PYG{p}{:}
        \PYG{n}{cbar2}\PYG{o}{.}\PYG{n}{set\PYGZus{}ticks}\PYG{p}{(}\PYG{p}{[}\PYG{n}{grid}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{cartopy}\PYG{o}{.}\PYG{n}{mpl}\PYG{o}{.}\PYG{n}{geoaxes}\PYG{o}{.}\PYG{n}{GeoAxes}\PYG{o}{.}\PYG{n}{gridlines}\PYG{p}{(}\PYG{n}{ax1}\PYG{p}{,}\PYG{n}{crs}\PYG{o}{=}\PYG{n}{ccrs}\PYG{o}{.}\PYG{n}{PlateCarree}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{draw\PYGZus{}labels}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{ax1}\PYG{o}{.}\PYG{n}{add\PYGZus{}feature}\PYG{p}{(}\PYG{n}{cartopy}\PYG{o}{.}\PYG{n}{feature}\PYG{o}{.}\PYG{n}{OCEAN}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{n}{alpha\PYGZus{}ocean}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{99}\PYG{p}{,} \PYG{n}{facecolor}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsh{}BBBBBB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{ax1}\PYG{o}{.}\PYG{n}{coastlines}\PYG{p}{(}\PYG{n}{resolution}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{50m}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{linewidth}\PYG{o}{=}\PYG{n}{coast\PYGZus{}line\PYGZus{}width}\PYG{p}{)}

    \PYG{k}{if} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n}{save\PYGZus{}way} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{)} \PYG{p}{:}
        \PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{save\PYGZus{}way}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{/}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sup\PYGZus{}name}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZus{}subsidence\PYGZus{}map\PYGZus{}at\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{time}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZus{}model\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{name}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{.pdf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Based on the output we can calculate the total subsidence induced by the cumulated load of ocean, and sediment (no ice here)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grid}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{L}\PYG{p}{)}
\PYG{n}{grid}\PYG{o}{=}\PYG{n}{grid}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{n}{grid}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{grid}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}grid=grid[1]+grid[2]+grid[3]}
\PYG{n}{color\PYGZus{}for\PYGZus{}final}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{0.7}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.6}\PYG{p}{,}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mf}{0.8}\PYG{p}{,}\PYG{l+m+mf}{0.6}\PYG{p}{,}\PYG{l+m+mf}{0.6}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{}contours=[\PYGZhy{}3,\PYGZhy{}2,\PYGZhy{}1,\PYGZhy{}0.5,\PYGZhy{}0.2,\PYGZhy{}0.1,0,0.1,0.2] \PYGZsh{} Ayeyarwady}
\PYG{n}{contours}\PYG{o}{=}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.4}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.3}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Gange}
\PYG{n}{mapplot}\PYG{p}{(}\PYG{n}{lon}\PYG{p}{,}\PYG{n}{lat}\PYG{p}{,}\PYG{n}{grid}\PYG{p}{,}\PYG{n}{area}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l32\PYGZus{}AYS1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{min\PYGZus{}max\PYGZus{}Total}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vmin}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{vmax}\PYG{o}{=}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{n}{save\PYGZus{}way}\PYG{o}{=}\PYG{n}{Input\PYGZus{}way}\PYG{p}{,}\PYG{n}{contour}\PYG{o}{=}\PYG{n}{contours}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{n}{color\PYGZus{}for\PYGZus{}final}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Mathematical Theory}
\label{\detokenize{Theory:mathematical-theory}}\label{\detokenize{Theory::doc}}
\sphinxAtStartPar
Most of our code is based on the mathematic and computational theory from {[}\hyperlink{cite.index:id3}{Dalca \sphinxstyleemphasis{et al.}, 2013}{]}.

\noindent\sphinxincludegraphics{{Fonctionnalite_Python}.pdf}


\subsection{The SLE}
\label{\detokenize{Theory:the-sle}}
\sphinxAtStartPar
The Relative sea level (\(\Delta SL\)) variations is the result of the interaction between the vertical mouvement of geoïd, \(\Delta Gtot\) (surface of the ocean) and the vertical mouvement of the ground, \(\Delta Rtot\) (called subsidence). We can then express the equation as :
\begin{equation*}
\begin{split}\Delta SL(\Theta,\Psi,t) = \Delta Gtot(\Theta,\Psi,t) - \Delta Rtot(\Theta,\Psi,t) -\Delta H - Delta I\end{split}
\end{equation*}
\sphinxAtStartPar
The geoïd variation include both, variation of the geoïd \(\Delta\mathcal{G}tot\) surface and variation of the ocean volume. The variation of the ocean volume following a conservation of the mass, denoted \(\frac{\Delta \Phi}{g}\).
\begin{equation*}
\begin{split}\Delta Gtot(\Theta,\Psi,t)=\Delta\mathcal{G}tot (\Theta,\Psi,t)- \frac{\Delta \Phi}{g}\end{split}
\end{equation*}
\sphinxAtStartPar
Both geoïd and ground variations (\(\Delta Xtot\)) can be decomposed into variations (\(\Delta X\)) due to mass redistribution and varaitions induced by earth rotation (\(\Delta X^T\)).
\begin{equation*}
\begin{split}\Delta Xtot (\Theta,\Psi,t)=\Delta X^{T} (\Theta,\Psi,t)+\Delta X (\Theta,\Psi,t)\end{split}
\end{equation*}
\sphinxAtStartPar
The resulting SLE is :
\begin{equation*}
\begin{split}\begin{aligned}
\Delta SL(\Theta,\Psi,t) = \Delta\mathcal{G}^{T} (\Theta,\Psi,t)+\Delta\mathcal{G} (\Theta,\Psi,t)- \frac{\Delta \Phi}{g} \\  - \Delta R^{T} (\Theta,\Psi,t)-\Delta R (\Theta,\Psi,t) - \Delta H - \Delta I
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
This equation shows that variations in relative sea level are the result of the interaction of geoid and ground variations induced by mass variations, plus the effect of the earth’s rotation, plus respectively the redistribution of water masses between ice, sediment and ocean and variations in the earth’s surface due to sedimentary input and ice.


\subsection{Conservation of mass}
\label{\detokenize{Theory:conservation-of-mass}}
\sphinxAtStartPar
The term \(\frac{\Delta \Phi}{g}\) follows a conservation of mass equation based on the variation of ice (\(\Delta I\)) and ocean volume (\(\Delta S\)).
\begin{equation*}
\begin{split}\iint_{\Omega} \Delta I \mathrm{~d} \Omega=-\frac{\rho_{\mathrm{W}}}{\rho_{\mathrm{I}}} \iint_{\Omega} \Delta S \mathrm{~d} \Omega .\end{split}
\end{equation*}
\sphinxAtStartPar
\(\Delta S\) include three variations, the variations of the sea level, the variation of ocean volume due to ice ocean interaction and the variation of the ocean surface. These three variations are expressed as follows :
\begin{equation*}
\begin{split}\Delta S=\Delta \mathcal{S} \mathcal{L} \cdot C+\frac{\Delta \Phi}{g} C-T_0\left[C-C_0\right]\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(T_0\) is the initial ocean volume and \(C\) is the ocean function (1 in the ocean and 0 on the continent) :
\begin{equation*}
\begin{split}C= \begin{cases}1 & \text { if } Z>0 \\ 0 & \text { if } Z \leq 0\end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
Injecting this expression to the conservation of mass we obtain :
\begin{equation*}
\begin{split}\begin{aligned}
\frac{\Delta \Phi}{g}= & -\frac{1}{\mathcal{A}} \frac{\rho_{\mathrm{I}}}{\rho_{\mathrm{w}}} \iint_{\Omega} \Delta I \mathrm{~d} \Omega-\frac{1}{\mathcal{A}} \iint_{\Omega} \Delta \mathcal{S} \mathcal{L} C \mathrm{~d} \Omega \\
& +\frac{1}{\mathcal{A}} \iint_{\Omega} T_0\left[C-C_0\right] \mathrm{d} \Omega,
\end{aligned}\end{split}
\end{equation*}
\sphinxAtStartPar
with \(\mathcal{A} \equiv \iint_{\Omega} C \mathrm{~d} \Omega\)

\sphinxAtStartPar
Behind the ocean function the variation of topography include ice and sediment thickness. The conservation term \(\frac{\Delta \Phi}{g}\) include then the replacement of ocean by sediment.


\subsection{Development of \protect\(\Delta G\protect\) and \protect\(\Delta R\protect\)}
\label{\detokenize{Theory:development-of-delta-g-and-delta-r}}\phantomsection\label{\detokenize{Theory:geoid-ground-variation-theory}}
\sphinxAtStartPar
To determine both \(\Delta G\) and \(\Delta R\), denoted from here \(\Delta \chi\), {[}\hyperlink{cite.index:id10}{Peltier, 1974}{]} and {[}\hyperlink{cite.index:id9}{Mitrovica and Peltier, 1989}{]} introduce the Green’s functions that describe the response of a radial symetric self gravitating sphere. The relation include a spatial and temporal convolution between the Green functions and the Load \(\Delta M\).
\begin{equation*}
\begin{split}\Delta \chi (\Theta,\Psi,t)=\int_{-\infty}^t \iint_{\Omega} \Delta M\left(\Theta^{\prime}, \Psi^{\prime}, t^{\prime}\right) \cdot G F\left(\gamma, t-t^{\prime}\right) \mathrm{d} \Omega^{\prime} \mathrm{d} t^{\prime}\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(\gamma\) is \(cos(\gamma) = cos(\theta)cos(\theta^{\prime}) + sin(\theta)sin(\theta^{\prime})cos(\psi-\psi^{\prime})\). GF here denote the Green function.


\subsubsection{Case of a non\sphinxhyphen{}rotational Earth}
\label{\detokenize{Theory:case-of-a-non-rotational-earth}}
\sphinxAtStartPar
The GFs follows the love numbers theory {[}\hyperlink{cite.index:id6}{Love, 1892}{]}. Our code differs from the work of {[}\hyperlink{cite.index:id3}{Dalca \sphinxstyleemphasis{et al.}, 2013}{]} by using decay love numbers where the normal mode of love numbers was used (see section xx for details about the love numbers used in this code). We use the h and k love numbers and derive for both the elastic (\(x_{\ell}^E\)) and viscous (decay, \(x_{\ell}^V(t)\)) part.

\sphinxAtStartPar
Here we are working on two GF, for the geoïd (\(\phi(\gamma,t)\)) and the ground (\(\Gamma(\gamma,t)\)) vertical motion.
\begin{equation*}
\begin{split}\phi(\gamma, t)=\frac{a g}{M_{\mathrm{e}}} \sum_{\ell=0}^{\infty}\left[\delta(t)+k_{\ell}^E \delta(t)+ k_{\ell}^V(t)\right] P_{\ell}(\cos \gamma)\end{split}
\end{equation*}\begin{equation*}
\begin{split}\Gamma(\gamma, t)=\frac{a g}{M_{\mathrm{e}}} \sum_{\ell=0}^{\infty}\left[h_{\ell}^E \delta(t)+h_{\ell}^V(t)\right] P_{\ell}(\cos \gamma)\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(a\) is the Earth radius, \(M_e\) the Earth mass, \(g\) the gravitational constant of earth and \(\delta(t)\) is the Dirac function. For the non\sphinxhyphen{}rotational part, in the convolution, GFs are applied to the Load (\(\Delta L (\Theta,\Psi,t)\)) a pure variation of masses.
\begin{equation*}
\begin{split}\Delta \chi (\Theta,\Psi,t)=\int_{-\infty}^t \iint_{\Omega} \Delta L\left(\Theta^{\prime}, \Psi^{\prime}, t^{\prime}\right) \cdot G F\left(\gamma, t-t^{\prime}\right) \mathrm{d} \Omega^{\prime} \mathrm{d} t^{\prime}\end{split}
\end{equation*}

\subsubsection{Case of a rotational Earth}
\label{\detokenize{Theory:case-of-a-rotational-earth}}
\sphinxAtStartPar
The effect of rotation on sea level is expressed by the perturbation of Earth’s rotational vector solved by using tidal love numbers \(k^T\) and \(h^T\) {[}\hyperlink{cite.index:id8}{Milne and Mitrovica, 1998}{]} in the GFs, for both elastic \(x_{\ell}^{T,E}\) and viscous \(x_{\ell}^{T,V}(t)\).
\begin{equation*}
\begin{split}\phi^T(\gamma, t)=\frac{a g}{M_{\mathrm{e}}} \sum_{\ell=0}^{\infty}\left[\delta(t)+k_{\ell}^{T,E} \delta(t)+ k_{\ell}^{T,V}(t)\right] P_{\ell}(\cos \gamma)\end{split}
\end{equation*}\begin{equation*}
\begin{split}\Gamma^T(\gamma, t)=\frac{a g}{M_{\mathrm{e}}} \sum_{\ell=0}^{\infty}\left[h_{\ell}^{T,E} \delta(t)+h_{\ell}^{T,V}(t)\right] P_{\ell}(\cos \gamma)\end{split}
\end{equation*}
\sphinxAtStartPar
Where

\sphinxAtStartPar
For the rotational Earth convolution a rotational potential is defined as \(\Lambda(\Theta,\Psi,t_j)\). The equations behind are described in {[}\hyperlink{cite.index:id8}{Milne and Mitrovica, 1998}{]} and are not developed here.


\subsection{Resolution of temporal and spatial convolution}
\label{\detokenize{Theory:resolution-of-temporal-and-spatial-convolution}}

\subsubsection{Spatial convolution}
\label{\detokenize{Theory:spatial-convolution}}
\sphinxAtStartPar
The spatial convolution is resolved using the spherical harmonic transformation. For a function \(\chi(\Theta,\Psi,t)\), we can define spherical harmonics coefficients \(\chi_{lm}(t)\), where \(l\) is the degree and \(m\) is the order of the associated Legendre polynomial (\(Y_{lm}(\Theta,\Psi)\)) :
\begin{equation*}
\begin{split}\mathcal{X} (\Theta,\Psi,t)=\sum_{lm} \mathcal{X} _{lm}(t)Y_{lm}(\Theta,\Psi)\end{split}
\end{equation*}
\sphinxAtStartPar
with \(\sum_{lm}=\sum_{l=0}^{\infty} \sum_{m=-l}^{m=l}\), for a degree l there is 2l+1 order.

\sphinxAtStartPar
In the spectral domain the convolution can be solved :
\begin{equation*}
\begin{split}\iint _{\Omega} \sum_{l=0}^{infty} \mathcal{X} (\Theta',\Psi',t)P_l(cos\gamma') \,d \Omega = T_l \sum_{lm} \mathcal{X} _{lm} (t) Y_{lm}(\Theta,\Psi)\end{split}
\end{equation*}\phantomsection\label{\detokenize{Theory:t-definition}}
\sphinxAtStartPar
With \(T_l = \frac{4\pi a^2}{2l+1}\)


\subsubsection{Temporal convolution}
\label{\detokenize{Theory:temporal-convolution}}
\sphinxAtStartPar
The resolution of temporal convolution is performed by a Heaviside distribution of the load \(\mathcal{H} (t)\).
\begin{quote}
\begin{equation*}
\begin{split}\mathcal{H} (t) = \left\{
    \begin{array}{ll}
        1 & \mbox{si t>0} \\
        \varnothing   & \mbox{si t=0} \\
        0 & \mbox{si t<0} \\
    \end{array}
\right.\end{split}
\end{equation*}\end{quote}

\sphinxAtStartPar
The Heavyside distributed load is :
\begin{equation*}
\begin{split}\Delta L(\Theta,\Psi,t)=\sum_{n=0}^{N} \delta L(\Theta,\Psi,t_n)\mathcal{H} (t-t_n)\end{split}
\end{equation*}

\subsubsection{Resolution of the convolutions}
\label{\detokenize{Theory:resolution-of-the-convolutions}}
\sphinxAtStartPar
Applying the temporal convolution resolution :
\begin{equation*}
\begin{split}\Delta \chi= \iint_{\Omega} \sum_{n=0}^{N} \delta M(\Theta,\Psi,t_n) \int_{-\infty}^t  \mathcal{H} (t-t_n) \cdot G F\left(\gamma, t-t^{\prime}\right) \mathrm{d} \Omega^{\prime} \mathrm{d} t^{\prime}\end{split}
\end{equation*}
\sphinxAtStartPar
and :
\begin{equation*}
\begin{split}\int_{-\infty}^t  \mathcal{H} (t-t_n) \cdot G F\left(\gamma, t-t^{\prime}\right) \mathrm{d} t^{\prime} = I G F\left(\gamma, t-t_n \right)\end{split}
\end{equation*}
\sphinxAtStartPar
with IGF the time integration of the GF.

\sphinxAtStartPar
We have then :
\begin{equation*}
\begin{split}\Delta \chi (\Theta,\Psi,t)= \iint_{\Omega} \sum_{n=0}^{j-1} \delta M(\Theta,\Psi,t_n) \cdot I G F\left(\gamma, t_j -t_n \right)\end{split}
\end{equation*}
\sphinxAtStartPar
By application of the spatial convolution solution :
\begin{equation*}
\begin{split}\Delta \chi (\Theta,\Psi,t)= \sum_{lm} T_l \sum_{n=0}^{j-1} \delta M_{lm} (t_n) Y_{lm}(\Theta,\Psi) \cdot I G F\left(\gamma, t-t_n \right)\end{split}
\end{equation*}
\sphinxAtStartPar
The respective IGF are :
\begin{equation*}
\begin{split}I \phi(\gamma, t)=\frac{a g}{M_{\mathrm{e}}} \sum_{\ell=0}^{\infty}\left[1+k_{\ell}^E+ K_{\ell}^V(t)\right]\end{split}
\end{equation*}\begin{equation*}
\begin{split}I \Gamma(\gamma, t)=\frac{a g}{M_{\mathrm{e}}} \sum_{\ell=0}^{\infty}\left[h_{\ell}^E +H_{\ell}^V(t)\right]\end{split}
\end{equation*}\begin{equation*}
\begin{split}I \phi^T(\gamma, t)=\frac{a g}{M_{\mathrm{e}}} \sum_{\ell=0}^{\infty}\left[1+k_{\ell}^{T,E} + K_{\ell}^{T,V}(t)\right]\end{split}
\end{equation*}\begin{equation*}
\begin{split}I \Gamma^T(\gamma, t)=\frac{a g}{M_{\mathrm{e}}} \sum_{\ell=0}^{\infty}\left[h_{\ell}^{T,E}+H_{\ell}^{T,V}(t)\right]\end{split}
\end{equation*}
\sphinxAtStartPar
Where K and H are the integrated love numbers between 0 and the considered time t.

\sphinxAtStartPar
The resulting SLE is :
\begin{equation*}
\begin{split}\Delta \mathcal{SL}(\Theta,\Psi,t) = \int_{-\infty}^{t_j} \iint_\Omega \Delta L (\Theta ^\prime, \Psi ^\prime,t ^\prime) \cdot [\frac{\Phi(\gamma, t - t^\prime)}{g} - \Gamma(\gamma,t-t^\prime)] \mathrm{d} \Omega ^\prime \mathrm{d} t^\prime - \Delta H(\Theta,\Psi,t) - \Delta I(\Theta,\Psi,t)\end{split}
\end{equation*}
\sphinxstepscope


\section{Numerical implementation}
\label{\detokenize{numerical_imp:numerical-implementation}}\label{\detokenize{numerical_imp::doc}}
\noindent\sphinxincludegraphics{{workflow}.pdf}
\phantomsection\label{\detokenize{numerical_imp:iteration-desc}}
\sphinxAtStartPar
The numerical implementation is using the derived impletation of {[}\hyperlink{cite.index:id3}{Dalca \sphinxstyleemphasis{et al.}, 2013}{]} from {[}\hyperlink{cite.index:id5}{Kendall \sphinxstyleemphasis{et al.}, 2005}{]}. This implementation is using two iteration counter, \(i\) and \(j\). \(j\) is associated to the time iteration and at each iteration the implementation iterate a convergence to find the best solution of the SLE where the counter is \(i\). The \(i\) counter will be called the inner iteration. From \(\delta S^{i=1}_j\) to \(\delta S^{i=\infty}_j\) to will calculate the best solution of SLE. The numerical implementation require a third counter, \(k\) called outer iteration, where the loop over the whole considered time is covered to improve first guess of initial topography, \(T_0^{k=1}\) until the convergence (\(T_0^{k=\infty}\)).

\sphinxAtStartPar
The SLE is rewrite to :
\begin{equation*}
\begin{split}\Delta \mathcal{SL}_j = \int_{-\infty}^{t_j} \iint_\Omega \Delta L (\Theta ^\prime, \Psi ^\prime,t ^\prime) \cdot [\frac{\Phi(\gamma, t_j - t^\prime)}{g} - \Gamma(\gamma,t_j-t^\prime)] \mathrm{d} \Omega ^\prime \mathrm{d} t^\prime - \Delta H_j - \Delta I_j\end{split}
\end{equation*}

\subsection{Sea Level equation resolution}
\label{\detokenize{numerical_imp:sea-level-equation-resolution}}

\subsubsection{Sea level equation Resolution implementation}
\label{\detokenize{numerical_imp:sea-level-equation-resolution-implementation}}\label{\detokenize{numerical_imp:sle-res}}
\sphinxAtStartPar
We introduce the variation of ocean thickness :
\begin{equation*}
\begin{split}\delta S^{i,k}_j=-\Delta S^{i=\infty,k}_{j-1} + \Delta \mathcal{SL}^{i-1,k}_j C^{k-1}_j + \frac{\Delta \Phi (t_j)^{i-1,k}}{g} C^{k-1}_j - T_0^{k-1}[C_j^{k-1} - C_0^{k-1}]\end{split}
\end{equation*}
\sphinxAtStartPar
If the last step of the outer iteration was completed, \(k-1\). The topography is updated :
\begin{equation*}
\begin{split}T_j^{k-1} = T_p  + \Delta SL_p^{i=\infty,k-1} - \Delta SL_j^{i=\infty,k-1}\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(T_p\) is the present day topography, we substract to the present day topography the earth movement. The resulting ocean function deduced from the reformulation of the topography is :

\phantomsection\label{\detokenize{numerical_imp:oc-func}}\begin{equation*}
\begin{split}C_j^{k-1} =
\begin{cases}
    1 & \text{if } T_j^{k-1} <0 \\
    0 & \text{if } T_j^{k-1} \geq 0
\end{cases}\end{split}
\end{equation*}
\sphinxAtStartPar
The sea level can be then estimated using a new estimation of the sea level change for the kth iteration.
\begin{equation*}
\begin{split}\Delta \mathcal{SL}^{i-1,k}_j = \Delta \mathcal{G}^{i-1,k}_j - (\Delta R^{i-1,k}_j+\Delta H_j + \Delta I_j^{k-1})\end{split}
\end{equation*}
\sphinxAtStartPar
for the first inner iteration \(i=1\), the initial variation of ocean thickness is predefine. The spatially invariant component is resulting from the variable ocean surface.
\begin{equation*}
\begin{split}\frac{\Delta \Phi ^{i-1,k}_j}{g} = \frac{-1}{\mathcal{A}^{k-1}_j} \frac{\rho_I}{\rho_w}\iint_\Omega\Delta I_j^{k-1} d\Omega - \frac{-1}{\mathcal{A}^{k-1}_j} \iint_\Omega \Delta \mathcal{SL}_j^{i-1,k} C_j^{k-1} d\Omega + \iint_\Omega T_0^{k-1}[C_j^{k-1} - C_0^{k-1}] d\Omega\end{split}
\end{equation*}
\sphinxAtStartPar
With
\begin{equation*}
\begin{split}\mathcal{A}^{k-1}_j=\iint_\Omega C_j^{k-1} d\Omega\end{split}
\end{equation*}

\subsubsection{Resolution of SLE including the deconvolution}
\label{\detokenize{numerical_imp:resolution-of-sle-including-the-deconvolution}}\phantomsection\label{\detokenize{numerical_imp:spec-sol}}
\sphinxAtStartPar
The implementation in iteration result in a modification of the geoid and ground displacement :
\begin{equation*}
\begin{split}\Delta \chi_j= \sum_{lm} T_l \sum_{n=0}^{j-1} \delta M_{lm} (t_n) Y_{lm}(\Theta,\Psi) \cdot I G F\left(\gamma, t_j-t_n \right)\end{split}
\end{equation*}
\sphinxAtStartPar
This applied to the SLE equation, by linearity of the IGFs:
\begin{equation*}
\begin{split}[\Delta \mathcal{SL}_{lm,j}]^{i-1,k}=T_l E_l \Delta M_{lm,j}^{k,i} + T_l \sum_{n=0}^{j-1} \beta (l,t_n,t_j)\delta M_{lm,n}^{k,i} +\frac{1}{g}E^T_l([\Delta \Lambda_{lm,j-1}]^{i=\infty,k} + [\delta \Lambda_{lm,j}]^{i-1,k})+ \frac{1}{g} \sum^{j-1}_{n=0} \beta^T(l,t_n,t_j)[\delta \Lambda_{lm,j}]^{i=\infty,k} - \Delta H_{lm,n}-[\Delta I_{lm,n}]^{k-1}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(E_l = 1 + k_l^E - h_l^E\), \(\beta(l,t_n,t_j)=k_l^V(t_j-t_n)-h_l^V(t_j-t_n)\) and \(T_l = \frac{4\pi a^2}{2l+1}\)

\sphinxAtStartPar
In SL\_C0de, \(T_l \sum_{n=0}^{j-1} \beta (l,t_n,t_j)\delta M_{lm,n}^{k,i}\) is resolved in matrix produce. This result in a strong allocation of RAM as the \(\beta (l,t_n,t_j)\) are stored in a matrix of size (time,time,(maximum degree + 1)(maximum degree +2)/2). The resulting time gain is very important.

\sphinxAtStartPar
The conservation formula become :
\begin{equation*}
\begin{split}\frac{\Delta \Phi_j}{g} = \frac{1}{C_{00,j}}(-\frac{\rho_i}{rho_w}\Delta I_{00,j}-RO_{00,j}+TO_{00,0})\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(RO_j = \Delta \mathcal{SL}_j C_j\) and \(TO_j=T_0[C_j-C_0]\).


\subsubsection{Convergence parameter}
\label{\detokenize{numerical_imp:convergence-parameter}}

\paragraph{Inner convergence on SLE}
\label{\detokenize{numerical_imp:inner-convergence-on-sle}}\phantomsection\label{\detokenize{numerical_imp:conv}}
\sphinxAtStartPar
We define a convergence criterion :
\begin{equation*}
\begin{split}\xi^{i,k}_j=|\frac{\sum_{l,m}|[\delta S_{lm}(t_j)]^{i,k}|-\sum_{l,m}|[\delta S_{lm}(t_j)]^{i-1,k}|}{\sum_{l,m}|[\delta S_{lm}(t_j)]^{i-1,k}|}|\end{split}
\end{equation*}
\sphinxAtStartPar
Convergence for the SLE is limited by the convergence criterion : \(\xi_j^{i,k}\). We suppose that \(\xi_j^{i,k} < \epsilon_1\) when
\begin{equation*}
\begin{split}[\delta S_{lm}(t_j)]^{i,k}=[\delta S_{lm}(t_j)]^{i=\infty,k}\end{split}
\end{equation*}

\paragraph{Outer convergence criterion}
\label{\detokenize{numerical_imp:outer-convergence-criterion}}

\subsubsection{Grounded ice correction}
\label{\detokenize{numerical_imp:grounded-ice-correction}}\phantomsection\label{\detokenize{numerical_imp:ice-corr}}
\sphinxAtStartPar
The marine grounded ice is dependent of RSL variations. The ice is grounded if it satisfies :
\begin{equation*}
\begin{split}I_j > (SL_j + I_j)\frac{\rho_w}{\rho_I}\end{split}
\end{equation*}
\sphinxAtStartPar
At each topographic iteration (\(k\)) we update the grounded ice.
\begin{equation*}
\begin{split}I_j^k =
\begin{cases}
    Ice\;Height & SL_j^{k-1} + Ice\;Height < 0 \\
    Ice\;Height & SL_j^{k-1} + Ice\;Height > 0 \\
     & and\;Ice\;Height > SL_j^{k-1},\frac{\rho_w}{\rho_I-\rho_w} \\
    0 & elsewhere
\end{cases}\end{split}
\end{equation*}

\subsection{Computation of ground and geoid subsidence from different load source}
\label{\detokenize{numerical_imp:computation-of-ground-and-geoid-subsidence-from-different-load-source}}\phantomsection\label{\detokenize{numerical_imp:g-r-comp}}
\sphinxAtStartPar
A functionality developed in \(SL_{C0de}\) is the computation of the different component of the SLE separately, by type of Load and by viscous or elastic component. The development of this functionality was motivated by the necessity of exploring the different source of the RSL variation in a more and more complex modelization.


\subsubsection{Elastic components of SLE :}
\label{\detokenize{numerical_imp:elastic-components-of-sle}}
\sphinxAtStartPar
We define 4 elastique component in the SLE, the ground displacement \(\Delta R^E_{lm}\), the geoid displacement \(\Delta G^E_{lm}\), the rotational ground displacement \(\Delta R^{T,E}_{lm}\) and the rotational geoid displacement \(\Delta G^{T,E}_{lm}\).
\begin{equation*}
\begin{split}\Delta R^E_{lm,j} = T_l h_l^E \Delta M_{lm,j}^{k,i}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\Delta G^E_{lm,j} = T_l (1+k_l^E) \Delta M_{lm,j}^{k,i}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\Delta R^{T,E}_{lm,j}=\frac{1}{g}h^{T,E}_l([\Delta \Lambda_{lm,j-1}]^{i=\infty,k} + [\delta \Lambda_{lm,j}]^{i-1,k})\end{split}
\end{equation*}\begin{equation*}
\begin{split}\Delta G^{T,E}_{lm,j}=\frac{1}{g}(1+h^{T,E}_l)([\Delta \Lambda_{lm,j-1}]^{i=\infty,k} + [\delta \Lambda_{lm,j}]^{i-1,k})\end{split}
\end{equation*}

\subsubsection{Viscous components of the SLE :}
\label{\detokenize{numerical_imp:viscous-components-of-the-sle}}
\sphinxAtStartPar
We define also 4 viscous component in the SLE, the ground displacement \(\Delta R^V_{lm}\), the geoid displacement \(\Delta G^V_{lm}\), the rotational ground displacement \(\Delta R^{T,V}_{lm}\) and the rotational geoid displacement \(\Delta G^{T,V}_{lm}\).
\begin{equation*}
\begin{split}\Delta R^V_{lm,j}=  T_l \sum_{n=0}^{j-1} h^V_l(tj-tn)\delta M_{lm,n}^{k,i}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\Delta G^V_{lm,j}=  T_l \sum_{n=0}^{j-1} k^V_l(tj-tn)\delta M_{lm,n}^{k,i}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\Delta R^{T,V}_{lm,j}=\frac{1}{g} \sum^{j-1}_{n=0} h^V_l(tj-tn)[\delta \Lambda_{lm,j}]^{i=\infty,k}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\Delta G^{T,V}_{lm,j}=\frac{1}{g} \sum^{j-1}_{n=0} k^V_l(tj-tn)[\delta \Lambda_{lm,j}]^{i=\infty,k}\end{split}
\end{equation*}

\subsubsection{True sediment subsidence}
\label{\detokenize{numerical_imp:true-sediment-subsidence}}\phantomsection\label{\detokenize{numerical_imp:sed-subs}}
\sphinxAtStartPar
This library was originally developed to compute effect of sediment on RSL. We considered the pure effect of sediment on RSL but also a corrected effect of sediment from water replacement. The sediment, when they are deposited, replace water and then generates an uplift induced by the diminution of ocean thickness. We choose to correct the sediment from the ocean load.
\begin{equation*}
\begin{split}\delta M_{lm,n} = \delta H_{lm,n}C_{lm,n}\rho_w\end{split}
\end{equation*}
\sphinxAtStartPar
To estimate effect of sediment on RSL, you must substract the effect of the mass variation described above to the effect of sediment mass variation.


\subsubsection{Relative sea level variations}
\label{\detokenize{numerical_imp:relative-sea-level-variations}}
\sphinxAtStartPar
We estimate a pure RSL where the sea level is not including variations of sediment thickness and ice thickness.
\begin{equation*}
\begin{split}\Delta SL^{i-1,k}_j = \Delta \mathcal{G}^{i-1,k}_j - \Delta R^{i-1,k}_j + \frac{\Delta \Phi ^{i-1,k}_j}{g}\end{split}
\end{equation*}
\sphinxAtStartPar
The other estimation is the full RSL :
\begin{equation*}
\begin{split}\Delta SL^{i-1,k}_j = \Delta \mathcal{G}^{i-1,k}_j - (\Delta R^{i-1,k}_j+\Delta H_j + \Delta I_j^{k-1}) + \frac{\Delta \Phi ^{i-1,k}_j}{g}\end{split}
\end{equation*}
\sphinxAtStartPar
The resulting estimation of RSL can be compared with the ESL (only \(\frac{\Delta \Phi ^{i-1,k}_j}{g}\)).


\subsection{Input data format}
\label{\detokenize{numerical_imp:input-data-format}}

\subsubsection{Mass grid format}
\label{\detokenize{numerical_imp:mass-grid-format}}\phantomsection\label{\detokenize{numerical_imp:grid-format}}
\sphinxAtStartPar
The different mass grid can be input as height grid, converted to mass by a simple multiplication by a defined density or as mass grid directly. The grids can be irregular or regular, they are interpolated over a sphere using stripy. These data are input as the derivative variations over time.

\sphinxAtStartPar
The topography as initial parameter is the present day topography. The initialization will update the topography according to the ice and sediment thickness.


\subsubsection{Implementation of Love numbers}
\label{\detokenize{numerical_imp:implementation-of-love-numbers}}\phantomsection\label{\detokenize{numerical_imp:love}}
\sphinxAtStartPar
The {[}\hyperlink{cite.index:id3}{Dalca \sphinxstyleemphasis{et al.}, 2013}{]} theory is based on the love number theory which forces us to calculate love numbers. The love numbers exits in two forms, normal mode and decay. They can also include compressible processes. We choose for computation facilities to use the love numbers computed by ALMA3 code {[}\hyperlink{cite.index:id7}{Melini \sphinxstyleemphasis{et al.}, 2022}{]}. This code is calculating incompressible decay love numbers. Benchmarking on compressible vs incompressible love numbers have demonstrated no significant difference in computed vertical displacement over 256 spherical harmonics degree. We urge you to use this code with a degree higher than 256.

\sphinxAtStartPar
The code is working with a precise file structure for love numbers :

\begin{DUlineblock}{0em}
\item[] earth\_model\_name
\item[] ├── h\_e.dat
\item[] ├── h\_e\_T.dat
\item[] ├── h\_ve.dat
\item[] ├── h\_ve\_T.dat
\item[] ├── k\_e.dat
\item[] ├── k\_e\_T.dat
\item[] ├── k\_ve.dat
\item[] ├── k\_ve\_T.dat
\item[] ├── l\_e.dat
\item[] ├── l\_e\_T.dat
\item[] ├── l\_ve.dat
\item[] ├── l\_ve\_T.dat
\item[] └── time.dat
\end{DUlineblock}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Corresponding love number from equation to the file names}\label{\detokenize{numerical_imp:id5}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
file
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Love numbers
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
h\_e
&
\sphinxAtStartPar
\(h_{\ell}^E\)
\\
\sphinxhline
\sphinxAtStartPar
h\_e\_T
&
\sphinxAtStartPar
\(h_{\ell}^{T,E}\)
\\
\sphinxhline
\sphinxAtStartPar
h\_ve
&
\sphinxAtStartPar
\(h_{\ell}^V(t)\)
\\
\sphinxhline
\sphinxAtStartPar
h\_ve\_T
&
\sphinxAtStartPar
\(h_{\ell}^{T,V}(t)\)
\\
\sphinxhline
\sphinxAtStartPar
k\_e
&
\sphinxAtStartPar
\(k_{\ell}^E\)
\\
\sphinxhline
\sphinxAtStartPar
k\_e\_T
&
\sphinxAtStartPar
\(k_{\ell}^{T,E}\)
\\
\sphinxhline
\sphinxAtStartPar
k\_ve
&
\sphinxAtStartPar
\(k_{\ell}^V(t)\)
\\
\sphinxhline
\sphinxAtStartPar
k\_ve\_T
&
\sphinxAtStartPar
\(k_{\ell}^{T,V}(t)\)
\\
\sphinxhline
\sphinxAtStartPar
l\_e
&
\sphinxAtStartPar
\(l_{\ell}^E\)
\\
\sphinxhline
\sphinxAtStartPar
l\_ve
&
\sphinxAtStartPar
\(l_{\ell}^{T,E}\)
\\
\sphinxhline
\sphinxAtStartPar
l\_ve
&
\sphinxAtStartPar
\(l_{\ell}^V(t)\)
\\
\sphinxhline
\sphinxAtStartPar
l\_ve\_T
&
\sphinxAtStartPar
\(l_{\ell}^{T,V}(t)\)
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The time.dat file contains the time at which the viscous decay love numbers are computed. An example file of configurations files for ALMA3 is provided in the code supplementary files.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Add the link to the ALMA3 configuration files.
\end{sphinxadmonition}

\sphinxstepscope


\section{Developer guide}
\label{\detokenize{developer_guide:developer-guide}}\label{\detokenize{developer_guide::doc}}
\sphinxstepscope


\subsection{SOLVER}
\label{\detokenize{SOLVER_doc:solver}}\label{\detokenize{SOLVER_doc::doc}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The entire functions used here must be verified before publication of the code. They have not been tested yet.
\end{sphinxadmonition}


\subsubsection{\sphinxstylestrong{Functions}}
\label{\detokenize{SOLVER_doc:functions}}\index{Precomputation() (in module SL\_C0de.SOLVER)@\spxentry{Precomputation()}\spxextra{in module SL\_C0de.SOLVER}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SOLVER_doc:SL_C0de.SOLVER.Precomputation}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.SOLVER.}}\sphinxbfcode{\sphinxupquote{Precomputation}}}{\emph{\DUrole{n}{ice\_grid}}, \emph{\DUrole{n}{sed\_grid}}, \emph{\DUrole{n}{topo\_grid}}, \emph{\DUrole{n}{Output\_way}}, \emph{\DUrole{n}{stop}\DUrole{o}{=}\DUrole{default_value}{26}}, \emph{\DUrole{n}{step}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{maxdeg}\DUrole{o}{=}\DUrole{default_value}{512}}, \emph{\DUrole{n}{irregular\_time\_step}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{backend}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{SOLVER_doc:precomputation}}Precomputation method prepare the different data to match temporal and spatial resolution of the modelisation. spatial resolution (m,n) and temporal resolution (step). The input data format is described in {\hyperref[\detokenize{numerical_imp:grid-format}]{\sphinxcrossref{\DUrole{std,std-ref}{Mass grid format}}}}.


\paragraph{Attribute :}
\label{\detokenize{SOLVER_doc:attribute}}\begin{quote}
\begin{description}
\sphinxlineitem{ice\_grid}{[}dict(name = str, grid = np.array((n\_i,m\_i,t\_i)), time = np.array((t\_i,)), lon = np.array((n\_i)), lat = np.array((m\_i))){]}
\sphinxAtStartPar
ice thickness grid

\sphinxlineitem{sed\_grid}{[}dict(name = str, grid = np.array((n\_j,m\_j,t\_j)), time = np.array((t\_j,)), lon = np.array((n\_j)), lat = np.array((m\_j))){]}
\sphinxAtStartPar
sediment thickness

\sphinxlineitem{topo\_grid}{[}dict(name = str, grid = np.array((n\_k,m\_k)), lon = np.array((n\_j)), lat = np.array((m\_j))){]}
\sphinxAtStartPar
present topography

\sphinxlineitem{Output\_way}{[}str{]}
\sphinxAtStartPar
The filepath toward wich the different grid will be saved

\sphinxlineitem{stop}{[}float {]}
\sphinxAtStartPar
age at wich the computation stop

\sphinxlineitem{step}{[}float{]}
\sphinxAtStartPar
time step used for the temporal resolution of the model

\sphinxlineitem{maxdeg}{[}int {]}
\sphinxAtStartPar
The maximum degree of spherical harmonics, that define the spatial resolution of the model. (m = 2*maxdeg, n = maxdeg)

\sphinxlineitem{irregular\_time\_step}{[}np.array((time\_step\_number,)){]}
\sphinxAtStartPar
An irregular time array to compute the model over non regular time step

\sphinxlineitem{backend}{[}bool{]}
\sphinxAtStartPar
If required you can ask a backend during the run of each computation. True, will generate a backend, False will not. Defaul is False

\end{description}
\end{quote}


\paragraph{Returns :}
\label{\detokenize{SOLVER_doc:returns}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\sphinxAtStartPar
The data output of the function are saved to the output way.

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{SLE\_forward\_modeling() (in module SL\_C0de.SOLVER)@\spxentry{SLE\_forward\_modeling()}\spxextra{in module SL\_C0de.SOLVER}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SOLVER_doc:SL_C0de.SOLVER.SLE_forward_modeling}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.SOLVER.}}\sphinxbfcode{\sphinxupquote{SLE\_forward\_modeling}}}{\emph{\DUrole{n}{Input\_way}}, \emph{\DUrole{n}{ice\_name}}, \emph{\DUrole{n}{sed\_name}}, \emph{\DUrole{n}{topo\_name}}, \emph{\DUrole{n}{ocean\_name}}, \emph{\DUrole{n}{love\_way}}, \emph{\DUrole{n}{love\_file}}, \emph{\DUrole{n}{conv\_lim}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{SOLVER_doc:sle-forward-modeling}}SLE\_forward\_modeling method solve the SLE with no constrain on final topography. This result in a forward modeling of the SL. It can be used for test and exploration of models. For informations on iterations see {\hyperref[\detokenize{numerical_imp:iteration-desc}]{\sphinxcrossref{\DUrole{std,std-ref}{description of iteration}}}}.


\paragraph{Attribute :}
\label{\detokenize{SOLVER_doc:id1}}\begin{quote}
\begin{description}
\sphinxlineitem{Input\_way}{[}str{]}
\sphinxAtStartPar
File location of the input data (ice, sediment and topography)

\sphinxlineitem{ice\_name}{[}str{]}
\sphinxAtStartPar
The name of the ice data file

\sphinxlineitem{sed\_name}{[}str{]}
\sphinxAtStartPar
The name of the sediment data file

\sphinxlineitem{topo\_name}{[}str{]}
\sphinxAtStartPar
The name of the topographic data file

\sphinxlineitem{ocean\_name}{[}str{]}
\sphinxAtStartPar
The name of the output file containig the data on the ocean

\sphinxlineitem{love\_way}{[}str {]}
\sphinxAtStartPar
way of the love numbers file used to compute earth visco elastic deformation

\sphinxlineitem{conv\_lim}{[}float{]}
\sphinxAtStartPar
Limit of precision required for the convergence of the SLE resolution (10\textasciicircum{}\sphinxhyphen{}3)

\sphinxlineitem{output\_way}{[}str {]}
\sphinxAtStartPar
filepath for saving results of the modelisation

\end{description}
\end{quote}


\paragraph{Returns :}
\label{\detokenize{SOLVER_doc:id2}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\sphinxAtStartPar
The resulting ocean class object ({\hyperref[\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{OCEAN\_TIME\_GRID}}}}) containing the ocean thickness is saved in the outputway under the name ocean.

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{SLE\_solver() (in module SL\_C0de.SOLVER)@\spxentry{SLE\_solver()}\spxextra{in module SL\_C0de.SOLVER}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SOLVER_doc:SL_C0de.SOLVER.SLE_solver}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.SOLVER.}}\sphinxbfcode{\sphinxupquote{SLE\_solver}}}{\emph{\DUrole{n}{Input\_way}}, \emph{\DUrole{n}{ice\_name}}, \emph{\DUrole{n}{sed\_name}}, \emph{\DUrole{n}{topo\_name}}, \emph{\DUrole{n}{ocean\_name}}, \emph{\DUrole{n}{love\_way}}, \emph{\DUrole{n}{love\_file}}, \emph{\DUrole{n}{topo\_lim}}, \emph{\DUrole{n}{conv\_lim}}, \emph{\DUrole{n}{Output\_way}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{SOLVER_doc:sle-solver}}SLE\_solver solve the SLE and converge toward the actual topography. The computation of the SLE resolution is describe in {\hyperref[\detokenize{numerical_imp:sle-res}]{\sphinxcrossref{\DUrole{std,std-ref}{Sea level equation resolution}}}}. For informations on iterations see {\hyperref[\detokenize{numerical_imp:iteration-desc}]{\sphinxcrossref{\DUrole{std,std-ref}{description of iteration}}}}.


\paragraph{Attribute :}
\label{\detokenize{SOLVER_doc:id3}}\begin{quote}
\begin{description}
\sphinxlineitem{Input\_way}{[}str{]}
\sphinxAtStartPar
File location of the input data (ice, sediment and topography)

\sphinxlineitem{ice\_name}{[}str{]}
\sphinxAtStartPar
The name of the ice data file

\sphinxlineitem{sed\_name}{[}str{]}
\sphinxAtStartPar
The name of the sediment data file

\sphinxlineitem{topo\_name}{[}str{]}
\sphinxAtStartPar
The name of the topographic data file

\sphinxlineitem{ocean\_name}{[}str{]}
\sphinxAtStartPar
The name of the output file containig the data on the ocean

\sphinxlineitem{love\_way}{[}str {]}
\sphinxAtStartPar
way of the love numbers file used to compute earth visco elastic deformation

\sphinxlineitem{conv\_lim}{[}float{]}
\sphinxAtStartPar
Limit of precision required for the convergence of the SLE resolution (10\textasciicircum{}\sphinxhyphen{}3)

\sphinxlineitem{topo\_lim}{[}float{]}
\sphinxAtStartPar
Topography convergence limit toward wich the iteration will converge (1 m)

\sphinxlineitem{output\_way}{[}str {]}
\sphinxAtStartPar
filepath for saving results of the modelisation

\end{description}
\end{quote}


\paragraph{Returns :}
\label{\detokenize{SOLVER_doc:id4}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\sphinxAtStartPar
The resulting ocean class object ({\hyperref[\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{OCEAN\_TIME\_GRID}}}}), updated ice thickness ({\hyperref[\detokenize{GRID_doc/ICE_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{ICE\_TIME\_GRID}}}}) and updated  topography ({\hyperref[\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{TOPOGRAPHIC\_TIME\_GRID}}}}) are saved to output\_way.

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{Post\_process() (in module SL\_C0de.SOLVER)@\spxentry{Post\_process()}\spxextra{in module SL\_C0de.SOLVER}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SOLVER_doc:SL_C0de.SOLVER.Post_process}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.SOLVER.}}\sphinxbfcode{\sphinxupquote{Post\_process}}}{\emph{\DUrole{n}{Input\_way\_sed}}, \emph{\DUrole{n}{Input\_way\_model\_output}}, \emph{\DUrole{n}{love\_way}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{SOLVER_doc:post-process}}Post\_process calculate the earth viscoelastic response resulting from the different masses caculated with the SLE\_solver. This computation is made for all models available in the files.


\paragraph{Attribute :}
\label{\detokenize{SOLVER_doc:id5}}\begin{quote}
\begin{description}
\sphinxlineitem{input\_way\_sed}{[}str{]}
\sphinxAtStartPar
way where the sediment precomputed are stored

\sphinxlineitem{input\_way\_model\_output}{[}str{]}
\sphinxAtStartPar
filepath to the different masses calculated by the SLE solver

\sphinxlineitem{love\_way}{[}str{]}
\sphinxAtStartPar
way to the love number output

\end{description}
\end{quote}


\paragraph{Returns :}
\label{\detokenize{SOLVER_doc:id6}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\sphinxAtStartPar
The resulting LOAD and GEOID are stored in a LOAD file in the same file then the input files. The structure is based on the {\hyperref[\detokenize{GRID_doc/LOAD_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{LOAD\_TIME\_GRID}}}} class object.

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{calculate\_deformation() (in module SL\_C0de.SOLVER)@\spxentry{calculate\_deformation()}\spxextra{in module SL\_C0de.SOLVER}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SOLVER_doc:SL_C0de.SOLVER.calculate_deformation}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.SOLVER.}}\sphinxbfcode{\sphinxupquote{calculate\_deformation}}}{\emph{\DUrole{n}{love\_number}}, \emph{\DUrole{n}{ice\_time\_grid}}, \emph{\DUrole{n}{sed\_time\_grid}}, \emph{\DUrole{n}{ocean\_time\_grid}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{Me}}, \emph{\DUrole{n}{Output\_way}}, \emph{\DUrole{n}{backend}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{SOLVER_doc:calculate-deformation}}calculate\_deformation method calculate the earth viscoelastic response resulting from the different masses caculated with the {\hyperref[\detokenize{SOLVER_doc:sle-solver}]{\sphinxcrossref{\DUrole{std,std-ref}{SLE\_solver}}}}. This computation follows the decomposition of the SLE described in {\hyperref[\detokenize{numerical_imp:g-r-comp}]{\sphinxcrossref{\DUrole{std,std-ref}{Computation of ground and geoid subsidence from different load source}}}}


\paragraph{Attribute :}
\label{\detokenize{SOLVER_doc:id7}}\begin{quote}
\begin{description}
\sphinxlineitem{love\_number}{[}{\hyperref[\detokenize{love_doc:id5}]{\sphinxcrossref{\DUrole{std,std-ref}{LOVE}}}} {]}
\sphinxAtStartPar
The loaded love number in the form of a LOVE class object

\sphinxlineitem{ice\_time\_grid}{[}{\hyperref[\detokenize{GRID_doc/ICE_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{grid.ICE\_TIME\_GRID}}}}{]}
\sphinxAtStartPar
ice thickness in the form of ICE\_TIME\_GRID class object

\sphinxlineitem{sed\_time\_grid}{[}{\hyperref[\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{grid.SEDIMENT\_TIME\_GRID}}}} {]}
\sphinxAtStartPar
sediment thickness in the form of SEDIMENT\_TIME\_GRID class object

\sphinxlineitem{ocean\_time\_grid}{[}{\hyperref[\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{grid.OCEAN\_TIME\_GRID}}}} {]}
\sphinxAtStartPar
ocean thickness calculated using the SLE solver in the form of OCEAN\_TIME\_GRID class object

\sphinxlineitem{a}{[}float{]}
\sphinxAtStartPar
radius of earth in meter

\sphinxlineitem{Me}{[}float{]}
\sphinxAtStartPar
mass of earth (kg)

\sphinxlineitem{Output\_way}{[}str{]}
\sphinxAtStartPar
way of the output where the load is calculated

\sphinxlineitem{backend}{[}bool{]}
\sphinxAtStartPar
set if the function is writing its state of computation

\end{description}
\end{quote}


\paragraph{Returns :}
\label{\detokenize{SOLVER_doc:id8}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\sphinxAtStartPar
The resulting LOAD and GEOID are stored in a LOAD file in the same file then the input files. The structure is based on the {\hyperref[\detokenize{GRID_doc/LOAD_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{LOAD\_TIME\_GRID}}}}  class object.

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{calculate\_sediment\_ocean\_interaction() (in module SL\_C0de.SOLVER)@\spxentry{calculate\_sediment\_ocean\_interaction()}\spxextra{in module SL\_C0de.SOLVER}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SOLVER_doc:SL_C0de.SOLVER.calculate_sediment_ocean_interaction}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.SOLVER.}}\sphinxbfcode{\sphinxupquote{calculate\_sediment\_ocean\_interaction}}}{\emph{\DUrole{n}{love\_number}}, \emph{\DUrole{n}{ice\_time\_grid}}, \emph{\DUrole{n}{sed\_time\_grid}}, \emph{\DUrole{n}{ocean\_time\_grid}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{Me}}, \emph{\DUrole{n}{topo\_time\_grid}}, \emph{\DUrole{n}{Output\_way}}, \emph{\DUrole{n}{backend}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{SOLVER_doc:calculate-sediment-ocean-interaction}}calculate\_sediment\_ocean\_interaction method calculate the earth viscoelastic response resulting from sediment under sea surface. This is used to retrieve the effect of ocean replacement by sediment on the sediment load. The resulting subsidence is the true subsidence induced by sediment. The problems and resolution in equation is described in {\hyperref[\detokenize{numerical_imp:sed-subs}]{\sphinxcrossref{\DUrole{std,std-ref}{True sediment subsidence}}}}.


\paragraph{Attribute :}
\label{\detokenize{SOLVER_doc:id9}}\begin{quote}
\begin{description}
\sphinxlineitem{love\_number}{[}{\hyperref[\detokenize{love_doc:id5}]{\sphinxcrossref{\DUrole{std,std-ref}{LOVE}}}} {]}
\sphinxAtStartPar
The loaded love number in the form of a LOVE class object

\sphinxlineitem{ice\_time\_grid}{[}{\hyperref[\detokenize{GRID_doc/ICE_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{grid.ICE\_TIME\_GRID}}}}{]}
\sphinxAtStartPar
ice thickness in the form of ICE\_TIME\_GRID class object

\sphinxlineitem{sed\_time\_grid}{[}{\hyperref[\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{grid.SEDIMENT\_TIME\_GRID}}}} {]}
\sphinxAtStartPar
sediment thickness in the form of SED\_TIME\_GRID class object

\sphinxlineitem{ocean\_time\_grid}{[}{\hyperref[\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{grid.OCEAN\_TIME\_GRID}}}} {]}
\sphinxAtStartPar
ocean thickness calculated using the SLE solver in the form of OCEAN\_TIME\_GRID class object

\sphinxlineitem{a}{[}float{]}
\sphinxAtStartPar
radius of earth in meter

\sphinxlineitem{Me}{[}float{]}
\sphinxAtStartPar
mass of earth (kg)

\sphinxlineitem{Output\_way}{[}str{]}
\sphinxAtStartPar
way of the output where the load is calculated

\sphinxlineitem{backend}{[}bool{]}
\sphinxAtStartPar
set if the function is writing its state of computation

\end{description}
\end{quote}


\paragraph{Returns :}
\label{\detokenize{SOLVER_doc:id10}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\sphinxAtStartPar
The resulting LOAD and GEOID are stored in a LOAD file in the same file then the input files. The structure is based on the {\hyperref[\detokenize{GRID_doc/LOAD_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{LOAD\_TIME\_GRID}}}} class object.

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{find\_files() (in module SL\_C0de.SOLVER)@\spxentry{find\_files()}\spxextra{in module SL\_C0de.SOLVER}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{SOLVER_doc:SL_C0de.SOLVER.find_files}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.SOLVER.}}\sphinxbfcode{\sphinxupquote{find\_files}}}{\emph{\DUrole{n}{filename}}, \emph{\DUrole{n}{search\_path}}}{}
\pysigstopsignatures
\end{fulllineitems}


\sphinxstepscope


\subsection{spharm}
\label{\detokenize{spharm_doc:spharm}}\label{\detokenize{spharm_doc::doc}}

\subsubsection{\sphinxstylestrong{Functions}}
\label{\detokenize{spharm_doc:functions}}\index{get\_coeffs() (in module SL\_C0de.spharm)@\spxentry{get\_coeffs()}\spxextra{in module SL\_C0de.spharm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spharm_doc:SL_C0de.spharm.get_coeffs}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.spharm.}}\sphinxbfcode{\sphinxupquote{get\_coeffs}}}{\emph{\DUrole{n}{a\_lm}}, \emph{\DUrole{n}{n}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{spharm_doc:get-coeffs}}get\_coeffs function get the spherical harmonics coefficients of the nth order from a linearly Spharm array.


\paragraph{Attribute :}
\label{\detokenize{spharm_doc:attribute}}\begin{quote}
\begin{description}
\sphinxlineitem{a\_lm}{[}np.array({[}maxdeg*(maxdeg+1)/2,{]}){]}
\sphinxAtStartPar
An array containing the spherical coefficient in a linear form

\sphinxlineitem{n}{[}int{]}
\sphinxAtStartPar
The order of the spherical harmonics coefficient you are trying to retrive

\end{description}
\end{quote}


\paragraph{Returns :}
\label{\detokenize{spharm_doc:returns}}\begin{quote}
\begin{description}
\sphinxlineitem{a\_n}{[}np.array({[}n,{]}){]}
\sphinxAtStartPar
The spherical harmonic coefficient of the order n.

\end{description}
\end{quote}

\end{fulllineitems}



\subsubsection{\sphinxstylestrong{CLASS}}
\label{\detokenize{spharm_doc:class}}\index{sphericalobject (class in SL\_C0de.spharm)@\spxentry{sphericalobject}\spxextra{class in SL\_C0de.spharm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spharm_doc:SL_C0de.spharm.sphericalobject}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{SL\_C0de.spharm.}}\sphinxbfcode{\sphinxupquote{sphericalobject}}}{\emph{\DUrole{n}{grd}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{maxdeg}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{spharm_doc:sphericalobject}}sphericalobject class include any spherical object. This class is working with pyshtools (\sphinxhref{https://shtools.github.io/SHTOOLS/}{pyshtools}).


\paragraph{Attributes}
\label{\detokenize{spharm_doc:attributes}}\begin{quote}
\begin{description}
\sphinxlineitem{grd}{[}np.array{[}(maxdeg,maxdeg x2){]}{]}
\sphinxAtStartPar
Value of the spherical object on a Gaussian Grid.

\sphinxlineitem{isgrd}{[}Bool{]}
\sphinxAtStartPar
A boolean to define if a Gaussian grid have been defined for this object.

\sphinxlineitem{coeff}{[}np.array{[}(maxdeg,maxdeg){]}{]}
\sphinxAtStartPar
Spherical harmonic coefficient array.

\sphinxlineitem{iscoeff}{[}Bool{]}
\sphinxAtStartPar
A boolean to define if a spherical harmonic coefficient have been defined for this object.

\sphinxlineitem{saved}{[}np.array{[}(n, maxdeg, maxdeg){]}{]}
\sphinxAtStartPar
An array wich contain the spherical harmonic coefficient each time th save method is applied.

\sphinxlineitem{prev}{[}np.array{[}(maxedg, maxdeg){]} {]}
\sphinxAtStartPar
save the spherical coefficient using save\_prev.

\end{description}
\end{quote}


\paragraph{Methods}
\label{\detokenize{spharm_doc:methods}}\begin{quote}
\begin{description}
\sphinxlineitem{{\hyperref[\detokenize{spharm_doc:grdtocoeff}]{\sphinxcrossref{grdtocoeff}}}}{[}{]}
\sphinxAtStartPar
Convert the Gaussian grid to spherical harmonic coefficient

\sphinxlineitem{{\hyperref[\detokenize{spharm_doc:coefftogrd}]{\sphinxcrossref{coefftogrd}}}}{[}{]}
\sphinxAtStartPar
Convert spherical harmonic coefficient to Gaussian grid

\sphinxlineitem{{\hyperref[\detokenize{spharm_doc:coefftogrdhd}]{\sphinxcrossref{coefftogrdhd}}} :}
\sphinxAtStartPar
Convert spherical harmonic coefficient to a Gaussian grid with a higher resolution then maxdeg

\sphinxlineitem{{\hyperref[\detokenize{spharm_doc:save-prev}]{\sphinxcrossref{save\_prev}}} :}
\sphinxAtStartPar
Save the spherical harmonic coefficient to the attribute prev

\end{description}
\end{quote}

\end{fulllineitems}



\subsubsection{\sphinxstylestrong{Methods}}
\label{\detokenize{spharm_doc:id1}}\index{grdtocoeff() (in module SL\_C0de.spharm.sphericalobject)@\spxentry{grdtocoeff()}\spxextra{in module SL\_C0de.spharm.sphericalobject}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spharm_doc:SL_C0de.spharm.sphericalobject.grdtocoeff}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.spharm.sphericalobject.}}\sphinxbfcode{\sphinxupquote{grdtocoeff}}}{\emph{\DUrole{n}{self}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{spharm_doc:grdtocoeff}}grdtocoeff method convert a Gaussian grid into spherical harmonic coefficient array using a numerical method to create spherical harmonic coefficient
self.coeff is updated usig these output.
self.iscoeff defining if a coefficient have been created for this object. 
If there is no grid created (self.isgrid == 0) then it returns an error.


\paragraph{Attribute :}
\label{\detokenize{spharm_doc:id2}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}


\paragraph{Returns :}
\label{\detokenize{spharm_doc:id3}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{coefftogrd() (in module SL\_C0de.spharm.sphericalobject)@\spxentry{coefftogrd()}\spxextra{in module SL\_C0de.spharm.sphericalobject}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spharm_doc:SL_C0de.spharm.sphericalobject.coefftogrd}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.spharm.sphericalobject.}}\sphinxbfcode{\sphinxupquote{coefftogrd}}}{\emph{\DUrole{n}{self}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{spharm_doc:coefftogrd}}coefftogrd method convert spherical harmonic coefficient into a gird array using shtools.
The output of pysh.SHCoeff are converted to real.
self.grd is updated usig these output.
self.isgrd defining if a grid have been created for this object. 
If there is no grid created (self.iscoeff == 0) then it returns an error.
A modifier pour pouvoir modifier les entrées de la fonction.

\sphinxAtStartPar
Parameters :

\sphinxAtStartPar
See the documentation of the cited class object for more information on different parameters used in the function.

\sphinxAtStartPar
Returns :

\sphinxAtStartPar
Added fields :

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{coefftogrdhd() (in module SL\_C0de.spharm.sphericalobject)@\spxentry{coefftogrdhd()}\spxextra{in module SL\_C0de.spharm.sphericalobject}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spharm_doc:SL_C0de.spharm.sphericalobject.coefftogrdhd}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.spharm.sphericalobject.}}\sphinxbfcode{\sphinxupquote{coefftogrdhd}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{max\_calc\_deg}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{spharm_doc:coefftogrdhd}}coefftogrdhd convert spherical harmonic coefficient into a gird array using shtools.
The output of pysh.SHCoeff are converted to real.
self.grd is updated usig these output.
self.isgrd defining if a grid have been created for this object. 
If there is no grid created (self.iscoeff == 0) then it returns an error.
A modifier pour pouvoir modifier les entrées de la fonction.


\paragraph{Attribute :}
\label{\detokenize{spharm_doc:id4}}\begin{quote}
\begin{description}
\sphinxlineitem{max\_calc\_deg}{[}int{]}
\sphinxAtStartPar
The maximum spherical harmonic degree to calculate the grid. This function can be used to have a better rendering in output.

\end{description}
\end{quote}


\paragraph{Returns :}
\label{\detokenize{spharm_doc:id5}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{save\_prev() (in module SL\_C0de.spharm.sphericalobject)@\spxentry{save\_prev()}\spxextra{in module SL\_C0de.spharm.sphericalobject}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{spharm_doc:SL_C0de.spharm.sphericalobject.save_prev}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.spharm.sphericalobject.}}\sphinxbfcode{\sphinxupquote{save\_prev}}}{\emph{\DUrole{n}{self}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{spharm_doc:save-prev}}save\_prev create a new field for the object to save the spherical coefficient at the moment of the applied function. 
This function make a clean copy of the array to avoid modification.


\paragraph{Attribute :}
\label{\detokenize{spharm_doc:id6}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}


\paragraph{Returns :}
\label{\detokenize{spharm_doc:id7}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsection{Grid}
\label{\detokenize{Grid_doc:grid}}\label{\detokenize{Grid_doc::doc}}
\sphinxAtStartPar
The Grid module is used to manage all the data in there version grided. This module define object class forgrid management, time grid management.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Je doit creuser plus en détail la relation avec le module Love pour éviter tout problème.
\end{sphinxadmonition}

\sphinxstepscope


\subsubsection{GRID}
\label{\detokenize{GRID_doc/GRID_class_doc:grid}}\label{\detokenize{GRID_doc/GRID_class_doc::doc}}

\paragraph{\sphinxstylestrong{CLASS}}
\label{\detokenize{GRID_doc/GRID_class_doc:class}}\index{GRID (class in SL\_C0de.grid)@\spxentry{GRID}\spxextra{class in SL\_C0de.grid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/GRID_class_doc:SL_C0de.grid.GRID}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{SL\_C0de.grid.}}\sphinxbfcode{\sphinxupquote{GRID}}}
\pysigstopsignatures
\sphinxAtStartPar
The class \phantomsection\label{\detokenize{GRID_doc/GRID_class_doc:id1}}GRID is used to represent the Gaussian Grid.


\subparagraph{Attributes}
\label{\detokenize{GRID_doc/GRID_class_doc:attributes}}\begin{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This grid have no attribute * this might be changed in future version to be used as stand alone. The absence of attribute is the result of the use of this function in {\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{TIME\_GRID}}}} that use that define all parameters used in the init function of GRID.
\end{sphinxadmonition}
\end{quote}


\subparagraph{Methods}
\label{\detokenize{GRID_doc/GRID_class_doc:methods}}\begin{quote}
\begin{description}
\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/GRID_class_doc:interp-on}]{\sphinxcrossref{interp\_on}}}}{[}{]}
\sphinxAtStartPar
method used to interpolate the grid over the model grid.

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/GRID_class_doc:smooth-on}]{\sphinxcrossref{smooth\_on}}}}{[}{]}
\sphinxAtStartPar
method used to smooth the grid to reduce noise effect.

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/GRID_class_doc:disk}]{\sphinxcrossref{disk}}}}{[}{]}
\sphinxAtStartPar
method used to create a disk of certain shape to test parameters.

\end{description}
\end{quote}

\end{fulllineitems}



\paragraph{\sphinxstylestrong{Methods}}
\label{\detokenize{GRID_doc/GRID_class_doc:id2}}\index{interp\_on() (in module SL\_C0de.grid.GRID)@\spxentry{interp\_on()}\spxextra{in module SL\_C0de.grid.GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/GRID_class_doc:SL_C0de.grid.GRID.interp_on}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.GRID.}}\sphinxbfcode{\sphinxupquote{interp\_on}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{grd}}, \emph{\DUrole{n}{lon}}, \emph{\DUrole{n}{lat}}, \emph{\DUrole{n}{smoothing}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{grid\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}global\textquotesingle{}}}, \emph{\DUrole{n}{error}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The method \phantomsection\label{\detokenize{GRID_doc/GRID_class_doc:interp-on}}interp\_on interpolate a grid of data on the grid of the model calculated in the init function of {\hyperref[\detokenize{GRID_doc/GRID_class_doc:id1}]{\sphinxcrossref{GRID}}}. This function is using stripy library to pursue the interpolation (\sphinxhref{https://underworldcode.github.io/stripy/2.0.5b2/FrontPage.html}{Stripy library}).


\subparagraph{Attribute}
\label{\detokenize{GRID_doc/GRID_class_doc:attribute}}\begin{quote}
\begin{description}
\sphinxlineitem{grd}{[}np.array({[}m,n{]}){]}
\sphinxAtStartPar
The grid data over space.

\sphinxlineitem{lon}{[}np.array({[}m,{]}){]}
\sphinxAtStartPar
The longitude of the data.

\sphinxlineitem{lat}{[}np.array({[}n,{]}){]}
\sphinxAtStartPar
The latitude of the data.

\sphinxlineitem{smoothing}{[}bool{]}
\sphinxAtStartPar
If a smoothing is applied to the grid before the interpolation, see {\hyperref[\detokenize{GRID_doc/GRID_class_doc:smooth-on}]{\sphinxcrossref{smooth\_on}}}.

\sphinxlineitem{grid\_type}{[}str{]}
\sphinxAtStartPar
grid type define if it’s a grid over the whole world or over a small area. This is used to avoid long computation for the interpolation in the case of interpolating small areas over the world. There is two possible ‘global’ and ‘local’. The global interpolation is using \sphinxhref{https://underworldcode.github.io/stripy/2.0.5b2/SphericalMeshing/SphericalTriangulations/Ex3-Interpolation.html}{stripy.sTriangulaion}. The local interpolation is using \sphinxhref{https://underworldcode.github.io/stripy/2.0.5b2/SphericalMeshing/CartesianTriangulations/Ex3-Interpolation.html}{stripyt.Triangulation}.

\sphinxlineitem{error}{[}bool{]}
\sphinxAtStartPar
If true, the method return the error of the interpolation calculated by stripy.

\end{description}
\end{quote}


\subparagraph{Return}
\label{\detokenize{GRID_doc/GRID_class_doc:return}}\begin{quote}
\begin{description}
\sphinxlineitem{grd}{[}np.array({[}maxdeg*2,maxdeg{]}){]}
\sphinxAtStartPar
The grid interpolated on the model grid.

\end{description}
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{smooth\_on() (in module SL\_C0de.grid.GRID)@\spxentry{smooth\_on()}\spxextra{in module SL\_C0de.grid.GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/GRID_class_doc:SL_C0de.grid.GRID.smooth_on}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.GRID.}}\sphinxbfcode{\sphinxupquote{smooth\_on}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{grd}}, \emph{\DUrole{n}{lon}}, \emph{\DUrole{n}{lat}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The method \phantomsection\label{\detokenize{GRID_doc/GRID_class_doc:smooth-on}}smooth\_on is smoothing the grid over the area whith \sphinxhref{https://underworldcode.github.io/stripy/2.0.5b2/SphericalMeshing/CartesianTriangulations/Ex5-Smoothing.html}{smoothing}. This function can be used to correct values before the interpolation over time and space. This way, you can have better results on topographic convergence.


\subparagraph{Attribute}
\label{\detokenize{GRID_doc/GRID_class_doc:id3}}\begin{quote}
\begin{description}
\sphinxlineitem{grd}{[}np.array({[}m,n{]}){]}
\sphinxAtStartPar
Array containig the grid values over the space.

\sphinxlineitem{lat}{[}nparray({[}n,{]}){]}
\sphinxAtStartPar
latitude.

\sphinxlineitem{lon}{[}nparray({[}m,{]}){]}
\sphinxAtStartPar
longitude.

\end{description}
\end{quote}


\subparagraph{Return}
\label{\detokenize{GRID_doc/GRID_class_doc:id4}}\begin{quote}
\begin{description}
\sphinxlineitem{grd}{[}np.array({[}m,n{]}){]}
\sphinxAtStartPar
smoothed array with the same shape then the initial grid.

\end{description}
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{disk() (in module SL\_C0de.grid.GRID)@\spxentry{disk()}\spxextra{in module SL\_C0de.grid.GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/GRID_class_doc:SL_C0de.grid.GRID.disk}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.GRID.}}\sphinxbfcode{\sphinxupquote{disk}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{lat}}, \emph{\DUrole{n}{lon}}, \emph{\DUrole{n}{radius}}, \emph{\DUrole{n}{high}}, \emph{\DUrole{n}{tx}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
\phantomsection\label{\detokenize{GRID_doc/GRID_class_doc:disk}}disk is a method used to create a thickness grid. This grid can be used to test different parameters.


\subparagraph{Attribute}
\label{\detokenize{GRID_doc/GRID_class_doc:id5}}\begin{quote}
\begin{description}
\sphinxlineitem{lat}{[}nparray({[}1,{]}){]}
\sphinxAtStartPar
Array contaning the latitudinal coordinate in degree of the center of the disk.

\sphinxlineitem{lon}{[}nparray(1,{[}{]}){]}
\sphinxAtStartPar
Array containing the longitudinal coordinate in degree of the center of the disk.

\sphinxlineitem{radius}{[}double{]}
\sphinxAtStartPar
The radius in degree of the disk in degree.

\sphinxlineitem{high}{[}double{]}
\sphinxAtStartPar
The thickness in meter of the disk over the considered area.

\end{description}
\end{quote}


\subparagraph{Return}
\label{\detokenize{GRID_doc/GRID_class_doc:id6}}\begin{quote}
\begin{description}
\sphinxlineitem{grd}{[}np.array({[}maxdeg*2,maxdeg{]}){]}
\sphinxAtStartPar
The grid as defined by the {\hyperref[\detokenize{GRID_doc/GRID_class_doc:id1}]{\sphinxcrossref{GRID}}} class with a disk of thikness high at lon,lat position with the size of radius.

\end{description}
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{zeros() (in module SL\_C0de.grid.GRID)@\spxentry{zeros()}\spxextra{in module SL\_C0de.grid.GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/GRID_class_doc:SL_C0de.grid.GRID.zeros}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.GRID.}}\sphinxbfcode{\sphinxupquote{zeros}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{tx}\DUrole{o}{=}\DUrole{default_value}{1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
\phantomsection\label{\detokenize{GRID_doc/GRID_class_doc:zeros}}zeros is a method used to generate a zero array with the caracteristics of the grid.


\subparagraph{Attribute :}
\label{\detokenize{GRID_doc/GRID_class_doc:id7}}\begin{quote}
\begin{description}
\sphinxlineitem{tx}{[}int{]}
\sphinxAtStartPar
times the thickness is repeated

\end{description}
\end{quote}


\subparagraph{Return :}
\label{\detokenize{GRID_doc/GRID_class_doc:id8}}\begin{quote}
\begin{description}
\sphinxlineitem{np.zeros((tx,self.lats.size,self.elons.size))}
\sphinxAtStartPar
An array containing only zeros

\end{description}
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{along\_transect() (in module SL\_C0de.grid.GRID)@\spxentry{along\_transect()}\spxextra{in module SL\_C0de.grid.GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/GRID_class_doc:SL_C0de.grid.GRID.along_transect}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.GRID.}}\sphinxbfcode{\sphinxupquote{along\_transect}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{coord}\DUrole{o}{=}\DUrole{default_value}{(\textquotesingle{}lat\_start\textquotesingle{}, \textquotesingle{}lon\_start\textquotesingle{}, \textquotesingle{}lat\_stop\textquotesingle{}, \textquotesingle{}lon\_stop\textquotesingle{})}}, \emph{\DUrole{n}{point\_density}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{point\_distance}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\end{fulllineitems}


\sphinxstepscope


\subsubsection{TIME\_GRID}
\label{\detokenize{GRID_doc/TIME_GRID_doc:time-grid}}\label{\detokenize{GRID_doc/TIME_GRID_doc::doc}}

\paragraph{\sphinxstylestrong{CLASS}}
\label{\detokenize{GRID_doc/TIME_GRID_doc:class}}\index{TIME\_GRID (class in SL\_C0de.grid)@\spxentry{TIME\_GRID}\spxextra{class in SL\_C0de.grid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:SL_C0de.grid.TIME_GRID}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{SL\_C0de.grid.}}\sphinxbfcode{\sphinxupquote{TIME\_GRID}}}{\emph{\DUrole{n}{time\_step}\DUrole{o}{=}\DUrole{default_value}{array({[}1, 2{]})}}, \emph{\DUrole{n}{maxdeg}\DUrole{o}{=}\DUrole{default_value}{64}}, \emph{\DUrole{n}{height\_time\_grid}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mass\_time\_grid}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mass\_time\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{height\_time\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{rho}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{grid\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}time\_grid\textquotesingle{}}}, \emph{\DUrole{n}{from\_file}\DUrole{o}{=}\DUrole{default_value}{(False,)}}, \emph{\DUrole{n}{superinit}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:id1}}TIME\_GRID class is used to manage the mass grids. These grids have a time dimenssion this way wa can manage the time variation of the mass. We can define the mass grid by it’s mass directly or by coupling a height with a density. If needed you can load spherical harmonics coefficient.Tis class is inheriting the methods from {\hyperref[\detokenize{spharm_doc:sphericalobject}]{\sphinxcrossref{\DUrole{std,std-ref}{sphericalobject}}}} and {\hyperref[\detokenize{GRID_doc/GRID_class_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{GRID}}}}.


\subparagraph{Attributes}
\label{\detokenize{GRID_doc/TIME_GRID_doc:attributes}}\begin{quote}
\begin{description}
\sphinxlineitem{time\_step}{[}np.array({[}time\_step\_number,{]}){]}
\sphinxAtStartPar
This array contains the time step of the data you are importing. They will be use for temporal interpolation.

\sphinxlineitem{maxdeg}{[}int{]}
\sphinxAtStartPar
Maximum harmonic coefficient degree of the data. this define the chape of the grid and coefficient arrays

\sphinxlineitem{height\_time\_grid}{[}np.array({[}maxedg*2,maxdeg{]}){]}
\sphinxAtStartPar
This array is the height grid at each time steps defined in grid\_time\_step

\sphinxlineitem{mass\_time\_grid}{[}np.array({[}maxedg*2,maxdeg{]}){]}
\sphinxAtStartPar
This array is the mass grid at each time steps defined in grid\_time\_step

\sphinxlineitem{height\_time\_coeff}{[}np.array({[}(maxdeg+1)(maxedg+2)/2,{]}){]}
\sphinxAtStartPar
This array is the height spherical harmonic coefficient at each time steps defined in grid\_time\_step

\sphinxlineitem{mass\_time\_coeff}{[}np.array({[}(maxdeg+1)(maxedg+2)/2,{]}){]}
\sphinxAtStartPar
This array is the mass spherical harmonic coefficient at each time steps defined in grid\_time\_step

\sphinxlineitem{rho}{[}float{]}
\sphinxAtStartPar
The density of the considered layer.

\end{description}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In future development the density may vary threw space and time. We’ll have to make a variable object more then a constant density.
\end{sphinxadmonition}
\begin{description}
\sphinxlineitem{grid\_name}{[}str{]}
\sphinxAtStartPar
The name of the grid. We recommand you to choose a specific name for each grid you create. This name is used to save the grid in an nc file with {\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:save}]{\sphinxcrossref{save}}}.

\sphinxlineitem{from\_file}{[}(bool,way){]}
\sphinxAtStartPar
This parameter define if the data are new or loaded from a previously saved model in a nc file. If the first element is False, the code will create a blank object, based on provided datas. If the first element is True, the method will get the data from the file way specified in the second element of this attribute.

\sphinxlineitem{superinit}{[}bool{]}
\sphinxAtStartPar
This parameter is used to specify if the object is used as herited method in an initialisation of a child class object.

\end{description}
\end{quote}


\subparagraph{Methods}
\label{\detokenize{GRID_doc/TIME_GRID_doc:methods}}\begin{quote}
\begin{description}
\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:interp-on-time}]{\sphinxcrossref{interp\_on\_time}}} }
\sphinxAtStartPar
Interpolate a grid over the time considered in the model

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:interp-on-time-and-space}]{\sphinxcrossref{interp\_on\_time\_and\_space}}} :}
\sphinxAtStartPar
Interpolate the grid over time and space as in the defined Grid during the initialisation of the class

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:grid-from-step}]{\sphinxcrossref{grid\_from\_step}}} :}
\sphinxAtStartPar
Get the grid for a defined time iteration

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:coeff-from-step}]{\sphinxcrossref{coeff\_from\_step}}} :}
\sphinxAtStartPar
Get the spherical harmonics coefficient for a defined time iteration

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:timegrdtotimecoeff}]{\sphinxcrossref{timegrdtotimecoeff}}} :}
\sphinxAtStartPar
Convert the grid into spherical harmonics coefficient for all time steps

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:timecoefftotimegrd}]{\sphinxcrossref{timecoefftotimegrd}}} :}
\sphinxAtStartPar
Convert the spherical harmonics coefficient into grid for all time steps

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:zeros-time}]{\sphinxcrossref{zeros\_time}}} :}
\sphinxAtStartPar
Generate a zero grid for all time steps

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:disk-time}]{\sphinxcrossref{disk\_time}}} :}
\sphinxAtStartPar
Generate a disk of a specified thickness at a specified location over all time steps

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:update-0}]{\sphinxcrossref{update\_0}}} :}
\sphinxAtStartPar
Update the 0 time step data of the grid

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:save}]{\sphinxcrossref{save}}} :}
\sphinxAtStartPar
Save the grid in a specified nc file with the name of the grid

\end{description}
\end{quote}

\end{fulllineitems}


\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This class is under active developement and not usable right now
\end{sphinxadmonition}


\paragraph{\sphinxstylestrong{Methods}}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id2}}\index{interp\_on\_time() (in module SL\_C0de.grid.TIME\_GRID)@\spxentry{interp\_on\_time()}\spxextra{in module SL\_C0de.grid.TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:SL_C0de.grid.TIME_GRID.interp_on_time}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{interp\_on\_time}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{grid\_to\_interp}}, \emph{\DUrole{n}{grid\_time\_step}}, \emph{\DUrole{n}{model\_time\_step}}, \emph{\DUrole{n}{interp\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}Thickness\_divide\textquotesingle{}}}, \emph{\DUrole{n}{backend}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}False\textquotesingle{}}}, \emph{\DUrole{n}{grid\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}regular\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The function \phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:interp-on-time}}interp\_on\_time is used for interpolation upon time and space it call the interpolation function of the {\hyperref[\detokenize{GRID_doc/GRID_class_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{GRID}}}} parameter. This function adapt the order of time and space interpolation to reduce computation time. The temporal interpolation try to preserve the thickness of the overall time. Tis is down by cutting and merging time steps of the original grid to match the model time\_step.


\subparagraph{Attributes}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id3}}\begin{quote}
\begin{description}
\sphinxlineitem{grid\_to\_interp}{[}np.array({[}k,n,m{]}){]}
\sphinxAtStartPar
The grid to be interpreted.

\sphinxlineitem{grid\_time\_step}{[}np.array({[}k,{]}){]}
\sphinxAtStartPar
The time value of each time step of the grid model.

\sphinxlineitem{model\_time\_step ; np.array({[}time\_step\_number,{]})}
\sphinxAtStartPar
The time values of the model.

\sphinxlineitem{interp\_type}{[}str{]}
\sphinxAtStartPar
No use of this parameter anymore

\sphinxlineitem{backend}{[}bool {]}
\sphinxAtStartPar
Define if the function retur, backends. True it will return the backends, False (default value) don’t give any backend.

\end{description}
\end{quote}


\subparagraph{Return :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:return}}\begin{quote}
\begin{description}
\sphinxlineitem{grid\_interpolated}{[}np.array({[}time\_step\_number,n,m{]}){]}
\sphinxAtStartPar
The interpolated grid over time. Depending of the model parameters.

\end{description}
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{interp\_on\_time\_and\_space() (in module SL\_C0de.grid.TIME\_GRID)@\spxentry{interp\_on\_time\_and\_space()}\spxextra{in module SL\_C0de.grid.TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:SL_C0de.grid.TIME_GRID.interp_on_time_and_space}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{interp\_on\_time\_and\_space}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{grid\_to\_interp}}, \emph{\DUrole{n}{grid\_time\_step}}, \emph{\DUrole{n}{grid\_lon}}, \emph{\DUrole{n}{grid\_lat}}, \emph{\DUrole{n}{interp\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}Thickness\_divide\textquotesingle{}}}, \emph{\DUrole{n}{backend}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{grid\_type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}global\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:interp-on-time-and-space}}interp\_on\_time\_and\_space function is used for interpolation upon time and space it call the interpolation function of the {\hyperref[\detokenize{GRID_doc/GRID_class_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{GRID}}}} parameter. This function perform the temporal and spatial interpolation in different order to ameliorate the computation time. If the temporal resolution of the input grid is higher than the model time resolution the temporal resolution will be perform first. The spatial resolution is performed first in the other case.


\subparagraph{Attributes}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id4}}\begin{quote}
\begin{description}
\sphinxlineitem{grid\_to\_interp}{[}np.array({[}k,n,m{]}){]}
\sphinxAtStartPar
The grid to be interpreted.

\sphinxlineitem{grid\_time\_step}{[}np.array({[}k,{]}){]}
\sphinxAtStartPar
The time value of each time step of the grid\_to\_interp.

\sphinxlineitem{grid\_lon}{[}np.array({[}n{]}){]}
\sphinxAtStartPar
The longitudinal coordinates of the grid\_to\_interp.

\sphinxlineitem{grid\_lat}{[}np.array({[}m{]}){]}
\sphinxAtStartPar
The latitudinal coordinate of the grid\_to\_interp.

\sphinxlineitem{interp\_type}{[}str{]}
\sphinxAtStartPar
No use of this parameter anymore

\sphinxlineitem{backend}{[}bool {]}
\sphinxAtStartPar
Define if the function retur, backends. True it will return the backends, False (default value) don’t give any backend.

\end{description}
\end{quote}


\subparagraph{Return :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id5}}\begin{quote}
\begin{description}
\sphinxlineitem{grid\_interpolated}{[}np.array({[}time\_step\_number,maxdeg*2,maxdeg{]}){]}
\sphinxAtStartPar
The interpolated grid over time. Depending of the model parameters.

\end{description}
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{grid\_from\_step() (in module SL\_C0de.grid.TIME\_GRID)@\spxentry{grid\_from\_step()}\spxextra{in module SL\_C0de.grid.TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:SL_C0de.grid.TIME_GRID.grid_from_step}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{grid\_from\_step}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{t\_it}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:grid-from-step}}grid\_from\_step method is used to get the value of the grid at the defined time step.


\subparagraph{Attributes :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id6}}\begin{quote}
\begin{description}
\sphinxlineitem{t\_it}{[}int{]}
\sphinxAtStartPar
This is the value of the time step iteration on wich you are trying to retreave the grid. It must inside the time\_step interpolation you have used during the initialisation of the time grid.

\end{description}
\end{quote}


\subparagraph{Return :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id7}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{coeff\_from\_step() (in module SL\_C0de.grid.TIME\_GRID)@\spxentry{coeff\_from\_step()}\spxextra{in module SL\_C0de.grid.TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:SL_C0de.grid.TIME_GRID.coeff_from_step}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{coeff\_from\_step}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{t\_it}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:coeff-from-step}}coeff\_from\_step method is used to get the value of the coefficient at the requested time iteration.


\subparagraph{Attributes :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id8}}\begin{quote}
\begin{description}
\sphinxlineitem{t\_it}{[}double{]}
\sphinxAtStartPar
This is the value of the time step iteration on wich you are trying to retreave the coefficient. It must be inside the time\_step interpolation you have used during the initialisation of the time grid.

\end{description}
\end{quote}


\subparagraph{Return :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id9}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{timegrdtotimecoeff() (in module SL\_C0de.grid.TIME\_GRID)@\spxentry{timegrdtotimecoeff()}\spxextra{in module SL\_C0de.grid.TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:SL_C0de.grid.TIME_GRID.timegrdtotimecoeff}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{timegrdtotimecoeff}}}{\emph{\DUrole{n}{self}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:timegrdtotimecoeff}}timegrdtotimecoeff method transform for each time step the grid into spherical harmonics coefficient.


\subparagraph{Attribute :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:attribute}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}


\subparagraph{Result :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:result}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{timecoefftotimegrd() (in module SL\_C0de.grid.TIME\_GRID)@\spxentry{timecoefftotimegrd()}\spxextra{in module SL\_C0de.grid.TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:SL_C0de.grid.TIME_GRID.timecoefftotimegrd}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{timecoefftotimegrd}}}{\emph{\DUrole{n}{self}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:timecoefftotimegrd}}timecoefftotimegrd method transform for each time step the spherical harmonic coefficient into a grid.


\subparagraph{Attribute :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id10}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}


\subparagraph{Result :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id11}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{zeros\_time() (in module SL\_C0de.grid.TIME\_GRID)@\spxentry{zeros\_time()}\spxextra{in module SL\_C0de.grid.TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:SL_C0de.grid.TIME_GRID.zeros_time}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{zeros\_time}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{time\_step\_number}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:zeros-time}}zeros\_time method is used to define a grid over time with only 0 value. It is based on {\hyperref[\detokenize{GRID_doc/GRID_class_doc:zeros}]{\sphinxcrossref{\DUrole{std,std-ref}{GRID.zeros}}}}.


\subparagraph{Attribute :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id12}}\begin{quote}
\begin{description}
\sphinxlineitem{time\_step\_number}{[}int{]}
\sphinxAtStartPar
The number of time step on wich we apply the zeros grid.

\end{description}
\end{quote}


\subparagraph{Return :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id13}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{disk\_time() (in module SL\_C0de.grid.TIME\_GRID)@\spxentry{disk\_time()}\spxextra{in module SL\_C0de.grid.TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:SL_C0de.grid.TIME_GRID.disk_time}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{disk\_time}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{time\_step\_number}}, \emph{\DUrole{n}{lat}}, \emph{\DUrole{n}{lon}}, \emph{\DUrole{n}{radius}}, \emph{\DUrole{n}{high}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:disk-time}}disk\_time method is used to define a grid over time with a disk defined with it’s center coordinate and the height. This function is based on {\hyperref[\detokenize{GRID_doc/GRID_class_doc:disk}]{\sphinxcrossref{\DUrole{std,std-ref}{GRID.disk}}}}.


\subparagraph{Attribute :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id14}}\begin{quote}
\begin{description}
\sphinxlineitem{time\_step\_number}{[}int{]}
\sphinxAtStartPar
The number of time step on wich the disk load will be applyed.

\sphinxlineitem{lat}{[}double{]}
\sphinxAtStartPar
The latitude of the center of the disk (°).

\sphinxlineitem{lon}{[}double{]}
\sphinxAtStartPar
The longitude of the center of the disk (°).

\sphinxlineitem{radius}{[}double{]}
\sphinxAtStartPar
The radius of the disk (°).

\sphinxlineitem{high}{[}double{]}
\sphinxAtStartPar
The high of the disk (m).

\end{description}
\end{quote}


\subparagraph{Return :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id15}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{update\_0() (in module SL\_C0de.grid.TIME\_GRID)@\spxentry{update\_0()}\spxextra{in module SL\_C0de.grid.TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:SL_C0de.grid.TIME_GRID.update_0}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{update\_0}}}{\emph{\DUrole{n}{self}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:update-0}}update\_0 function is used to save the first time iteration of the object before it’s modification to be called at any moment in the code without alteration.


\subparagraph{Attribute :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id16}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}


\subparagraph{Return :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id17}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{save() (in module SL\_C0de.grid.TIME\_GRID)@\spxentry{save()}\spxextra{in module SL\_C0de.grid.TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:SL_C0de.grid.TIME_GRID.save}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{save\_way}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}, \emph{\DUrole{n}{supersave}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/TIME_GRID_doc:save}}save function is used to save the grid and all it’s parameters inside a nc file. Parameters saved are, longitude, latitude, maximum degree, the time steps of the grid, the thickness of the grid, the harmonic coefficient, grid density. The harmonic coefficient, due to complexe data type management of nc, are saved separately in there complexe and real part. The created file will have the name of the grid.


\subparagraph{Attribute :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id18}}\begin{quote}
\begin{description}
\sphinxlineitem{save\_way}{[}str{]}
\sphinxAtStartPar
The filepath where the data will be saved. Default value is the current file

\sphinxlineitem{supersave}{[}bool{]}
\sphinxAtStartPar
Define if the save is called as a super method from an object that inherit the function. This precise if this method has to close the nc file (False) of if the herited class will do it (True). Default value is False.

\end{description}
\end{quote}


\subparagraph{Return :}
\label{\detokenize{GRID_doc/TIME_GRID_doc:id19}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{SEDIMENT\_TIME\_GRID}
\label{\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:sediment-time-grid}}\label{\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc::doc}}

\paragraph{\sphinxstylestrong{CLASS}}
\label{\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:class}}\index{SEDIMENT\_TIME\_GRID (class in SL\_C0de.grid)@\spxentry{SEDIMENT\_TIME\_GRID}\spxextra{class in SL\_C0de.grid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:SL_C0de.grid.SEDIMENT_TIME_GRID}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{SL\_C0de.grid.}}\sphinxbfcode{\sphinxupquote{SEDIMENT\_TIME\_GRID}}}{\emph{\DUrole{n}{time\_step}\DUrole{o}{=}\DUrole{default_value}{array({[}1, 2{]})}}, \emph{\DUrole{n}{maxdeg}\DUrole{o}{=}\DUrole{default_value}{64}}, \emph{\DUrole{n}{height\_time\_grid}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mass\_time\_grid}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mass\_time\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{height\_time\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{rho}\DUrole{o}{=}\DUrole{default_value}{2600}}, \emph{\DUrole{n}{grid\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}time\_grid\textquotesingle{}}}, \emph{\DUrole{n}{from\_file}\DUrole{o}{=}\DUrole{default_value}{(False,)}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:id1}}SEDIMENT\_TIME\_GRID class is used to represent sediment deposited thickness and time over time. It inherit from {\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{TIME\_GRID}}}} and just add a default value of sediment density at 2600 kg/m3.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This class must include the developement of {[}\hyperlink{cite.index:id4}{Ferrier \sphinxstyleemphasis{et al.}, 2017}{]} on sediment compaction and it’s effect on water redistriution.
\end{sphinxadmonition}


\subparagraph{Attributes}
\label{\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:attributes}}\begin{quote}
\begin{description}
\sphinxlineitem{time\_step}{[}np.array({[}time\_step\_number,{]}){]}
\sphinxAtStartPar
This array contains the time step of the data you are importing. They will be use for temporal interpolation.

\sphinxlineitem{maxdeg}{[}int{]}
\sphinxAtStartPar
Maximum harmonic coefficient degree of the data. this define the chape of the grid and coefficient arrays

\sphinxlineitem{height\_time\_grid}{[}np.array({[}maxedg*2,maxdeg{]}){]}
\sphinxAtStartPar
This array is the height grid at each time steps defined in grid\_time\_step

\sphinxlineitem{mass\_time\_grid}{[}np.array({[}maxedg*2,maxdeg{]}){]}
\sphinxAtStartPar
This array is the mass grid at each time steps defined in grid\_time\_step

\sphinxlineitem{height\_time\_coeff}{[}np.array({[}(maxdeg+1)(maxedg+2)/2,{]}){]}
\sphinxAtStartPar
This array is the height spherical harmonic coefficient at each time steps defined in grid\_time\_step

\sphinxlineitem{mass\_time\_coeff}{[}np.array({[}(maxdeg+1)(maxedg+2)/2,{]}){]}
\sphinxAtStartPar
This array is the mass spherical harmonic coefficient at each time steps defined in grid\_time\_step

\sphinxlineitem{rho}{[}float{]}
\sphinxAtStartPar
The density of the considered layer. Default value is 2600.

\end{description}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In future development the density may vary threw space and time. We’ll have to make a variable object more then a constant density.
\end{sphinxadmonition}
\begin{description}
\sphinxlineitem{grid\_name}{[}str{]}
\sphinxAtStartPar
The name of the grid. We recommand you to choose a specific name for each grid you create. This name is used to save the grid in an nc file with {\color{red}\bfseries{}\textasciigrave{}save\textasciigrave{}\_}.

\sphinxlineitem{from\_file}{[}(bool,way){]}
\sphinxAtStartPar
This parameter define if the data are new or loaded from a previously saved model in a nc file. If the first element is False, the code will create a blank object, based on provided datas. If the first element is True, the method will get the data from the file way specified in the second element of this attribute.

\end{description}
\end{quote}


\subparagraph{Method}
\label{\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:method}}\begin{quote}
\begin{description}
\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:sed-save}]{\sphinxcrossref{\DUrole{std,std-ref}{save}}}} }
\sphinxAtStartPar
used to save data

\end{description}
\end{quote}

\end{fulllineitems}



\paragraph{\sphinxstylestrong{METHODS}}
\label{\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:methods}}\index{save() (in module SL\_C0de.grid.SEDIMENT\_TIME\_GRID)@\spxentry{save()}\spxextra{in module SL\_C0de.grid.SEDIMENT\_TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:SL_C0de.grid.SEDIMENT_TIME_GRID.save}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.SEDIMENT\_TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{save\_way}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures\phantomsection\label{\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:sed-save}}
\sphinxAtStartPar
The save method is used to save the grid data to a file. It call the super method {\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:save}]{\sphinxcrossref{\DUrole{std,std-ref}{save}}}} method with no additional saved parameters.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Because we need to include {[}\hyperlink{cite.index:id4}{Ferrier \sphinxstyleemphasis{et al.}, 2017}{]} works, this save function will be modified to include data about the sediment compaction.
\end{sphinxadmonition}


\subparagraph{Attributes}
\label{\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:id4}}\begin{quote}
\begin{description}
\sphinxlineitem{rho}{[}float{]}
\sphinxAtStartPar
Density value of the sediment as a constant, default value is 2600.

\end{description}
\end{quote}


\subparagraph{Return}
\label{\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:return}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{ICE\_TIME\_GRID}
\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:ice-time-grid}}\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc::doc}}

\paragraph{\sphinxstylestrong{CLASS}}
\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:class}}\index{ICE\_TIME\_GRID (class in SL\_C0de.grid)@\spxentry{ICE\_TIME\_GRID}\spxextra{class in SL\_C0de.grid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:SL_C0de.grid.ICE_TIME_GRID}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{SL\_C0de.grid.}}\sphinxbfcode{\sphinxupquote{ICE\_TIME\_GRID}}}{\emph{\DUrole{n}{time\_step}\DUrole{o}{=}\DUrole{default_value}{array({[}1, 2{]})}}, \emph{\DUrole{n}{maxdeg}\DUrole{o}{=}\DUrole{default_value}{64}}, \emph{\DUrole{n}{height\_time\_grid}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mass\_time\_grid}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mass\_time\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{height\_time\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{rho}\DUrole{o}{=}\DUrole{default_value}{916.7}}, \emph{\DUrole{n}{grid\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}time\_grid\textquotesingle{}}}, \emph{\DUrole{n}{from\_file}\DUrole{o}{=}\DUrole{default_value}{(False,)}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:id1}}ICE\_TIME\_GRID class is used to represent the ice thickness evolution threw time. This class inherit of {\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{TIME\_GRID}}}}.

\sphinxAtStartPar
…


\subparagraph{Attributes}
\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:attributes}}\begin{quote}
\begin{description}
\sphinxlineitem{time\_step}{[}np.array({[}time\_step\_number,{]}){]}
\sphinxAtStartPar
This array contains the time step of the data you are importing. They will be use for temporal interpolation.

\sphinxlineitem{maxdeg}{[}int{]}
\sphinxAtStartPar
Maximum harmonic coefficient degree of the data. this define the chape of the grid and coefficient arrays

\sphinxlineitem{height\_time\_grid}{[}np.array({[}maxedg*2,maxdeg{]}){]}
\sphinxAtStartPar
This array is the height grid at each time steps defined in grid\_time\_step

\sphinxlineitem{mass\_time\_grid}{[}np.array({[}maxedg*2,maxdeg{]}){]}
\sphinxAtStartPar
This array is the mass grid at each time steps defined in grid\_time\_step

\sphinxlineitem{height\_time\_coeff}{[}np.array({[}(maxdeg+1)(maxedg+2)/2,{]}){]}
\sphinxAtStartPar
This array is the height spherical harmonic coefficient at each time steps defined in grid\_time\_step

\sphinxlineitem{mass\_time\_coeff}{[}np.array({[}(maxdeg+1)(maxedg+2)/2,{]}){]}
\sphinxAtStartPar
This array is the mass spherical harmonic coefficient at each time steps defined in grid\_time\_step

\sphinxlineitem{rho}{[}float{]}
\sphinxAtStartPar
The density of the considered layer. Default is 916.7 kg/m3.

\end{description}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In future development the density may vary threw space and time. We’ll have to make a variable object more then a constant density.
\end{sphinxadmonition}
\begin{description}
\sphinxlineitem{grid\_name}{[}str{]}
\sphinxAtStartPar
The name of the grid. We recommand you to choose a specific name for each grid you create. This name is used to save the grid in an nc file with {\color{red}\bfseries{}\textasciigrave{}save\textasciigrave{}\_}.

\sphinxlineitem{from\_file}{[}(bool,way){]}
\sphinxAtStartPar
This parameter define if the data are new or loaded from a previously saved model in a nc file. If the first element is False, the code will create a blank object, based on provided datas. If the first element is True, the method will get the data from the file way specified in the second element of this attribute.

\end{description}
\end{quote}


\subparagraph{Methods}
\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:methods}}\begin{quote}
\begin{description}
\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/ICE_TIME_GRID_doc:ice-correction}]{\sphinxcrossref{ice\_correction}}} }
\sphinxAtStartPar
correct the grounded ice thickness from the created floating ice by ground vertical mouvement

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/ICE_TIME_GRID_doc:ice-save}]{\sphinxcrossref{\DUrole{std,std-ref}{save}}}} }
\sphinxAtStartPar
used to save data

\end{description}
\end{quote}

\end{fulllineitems}



\paragraph{\sphinxstylestrong{METHODS}}
\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:id2}}\index{ice\_correction() (in module SL\_C0de.grid.ICE\_TIME\_GRID)@\spxentry{ice\_correction()}\spxextra{in module SL\_C0de.grid.ICE\_TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:SL_C0de.grid.ICE_TIME_GRID.ice_correction}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.ICE\_TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{ice\_correction}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{topo}}, \emph{\DUrole{n}{oc}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:ice-correction}}ice\_correction method is used to correct the grounded ice thickness from the floating ice generted by vertical ground motion. This correction is done for each time step to remove the floating ice.  The correction of grounded ice is based on {\hyperref[\detokenize{numerical_imp:ice-corr}]{\sphinxcrossref{\DUrole{std,std-ref}{Grounded ice correction}}}}.


\subparagraph{Attributes}
\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:id3}}\begin{quote}
\begin{description}
\sphinxlineitem{topo}{[}{\hyperref[\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{TOPOGRAPHIC\_TIME\_GRID}}}} class object{]}
\sphinxAtStartPar
A topogrphic grid object, used to check if grounded ice become floating ice. The topography is then modified to by this function.

\sphinxlineitem{oc}{[}{\hyperref[\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{OCEAN\_TIME\_GRID}}}} class object{]}
\sphinxAtStartPar
An oceanic time grid object used only to get the density of ocean set for the model.

\end{description}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
To avoid memory consumption the oc parameter should be replace simply by oc\_rho the ocean density.
\end{sphinxadmonition}
\end{quote}


\subparagraph{Return}
\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:return}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{save() (in module SL\_C0de.grid.ICE\_TIME\_GRID)@\spxentry{save()}\spxextra{in module SL\_C0de.grid.ICE\_TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:SL_C0de.grid.ICE_TIME_GRID.save}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.ICE\_TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{save\_way}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures\phantomsection\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:ice-save}}
\sphinxAtStartPar
The save method is used to save the data of the ice grid. Because of the {\hyperref[\detokenize{GRID_doc/ICE_TIME_GRID_doc:ice-correction}]{\sphinxcrossref{ice\_correction}}} method that update the grid we choosed to preserve the original ice thickness data in a ice parameter that is saved inside the nc file. Otherwise this method use the super method \DUrole{xref,std,std-ref}{save} to save the rest of the data.


\subparagraph{Attributes}
\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:id4}}\begin{quote}
\begin{description}
\sphinxlineitem{save\_way :str}
\sphinxAtStartPar
The way where the nc file is saved. Default value is the current file (an empty str).

\end{description}
\end{quote}


\subparagraph{Return}
\label{\detokenize{GRID_doc/ICE_TIME_GRID_doc:id5}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{OCEAN\_TIME\_GRID}
\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:ocean-time-grid}}\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc::doc}}

\paragraph{\sphinxstylestrong{CLASS}}
\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:class}}\index{OCEAN\_TIME\_GRID (class in SL\_C0de.grid)@\spxentry{OCEAN\_TIME\_GRID}\spxextra{class in SL\_C0de.grid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:SL_C0de.grid.OCEAN_TIME_GRID}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{SL\_C0de.grid.}}\sphinxbfcode{\sphinxupquote{OCEAN\_TIME\_GRID}}}{\emph{\DUrole{n}{time\_step}\DUrole{o}{=}\DUrole{default_value}{array({[}1, 2{]})}}, \emph{\DUrole{n}{maxdeg}\DUrole{o}{=}\DUrole{default_value}{64}}, \emph{\DUrole{n}{height\_time\_grid}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mass\_time\_grid}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mass\_time\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{height\_time\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{rho}\DUrole{o}{=}\DUrole{default_value}{1000}}, \emph{\DUrole{n}{grid\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}time\_grid\textquotesingle{}}}, \emph{\DUrole{n}{from\_file}\DUrole{o}{=}\DUrole{default_value}{(False,)}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:id1}}OCEAN\_TIME\_GRID class is used to represent the ocean thickness variation and contains the method to resolve the sea level equation. This method inherit from {\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{TIME\_GRID}}}}.

\sphinxAtStartPar
…


\subparagraph{Attributes}
\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:attributes}}\begin{quote}
\begin{description}
\sphinxlineitem{time\_step}{[}np.array({[}time\_step\_number,{]}){]}
\sphinxAtStartPar
This array contains the time step of the data you are importing. They will be use for temporal interpolation.

\sphinxlineitem{maxdeg}{[}int{]}
\sphinxAtStartPar
Maximum harmonic coefficient degree of the data. this define the chape of the grid and coefficient arrays

\sphinxlineitem{height\_time\_grid}{[}np.array({[}maxedg*2,maxdeg{]}){]}
\sphinxAtStartPar
This array is the height grid at each time steps defined in grid\_time\_step

\sphinxlineitem{mass\_time\_grid}{[}np.array({[}maxedg*2,maxdeg{]}){]}
\sphinxAtStartPar
This array is the mass grid at each time steps defined in grid\_time\_step

\sphinxlineitem{height\_time\_coeff}{[}np.array({[}(maxdeg+1)(maxedg+2)/2,{]}){]}
\sphinxAtStartPar
This array is the height spherical harmonic coefficient at each time steps defined in grid\_time\_step

\sphinxlineitem{mass\_time\_coeff}{[}np.array({[}(maxdeg+1)(maxedg+2)/2,{]}){]}
\sphinxAtStartPar
This array is the mass spherical harmonic coefficient at each time steps defined in grid\_time\_step

\sphinxlineitem{rho}{[}float{]}
\sphinxAtStartPar
The density of the considered layer. Default is 1000 kg/m3.

\end{description}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In future development the density may vary threw space and time. We’ll have to make a variable object more then a constant density.
\end{sphinxadmonition}
\begin{description}
\sphinxlineitem{grid\_name}{[}str{]}
\sphinxAtStartPar
The name of the grid. We recommand you to choose a specific name for each grid you create. This name is used to save the grid in an nc file with {\color{red}\bfseries{}\textasciigrave{}save\textasciigrave{}\_}.

\sphinxlineitem{from\_file}{[}(bool,way){]}
\sphinxAtStartPar
This parameter define if the data are new or loaded from a previously saved model in a nc file. If the first element is False, the code will create a blank object, based on provided datas. If the first element is True, the method will get the data from the file way specified in the second element of this attribute.

\end{description}
\end{quote}


\subparagraph{Methods}
\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:methods}}\begin{quote}
\begin{description}
\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:update-0-oce}]{\sphinxcrossref{\DUrole{std,std-ref}{update\_0}}}}}
\sphinxAtStartPar
set the grd\_0 from the actual grd loaded in the grid

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:evaluate-ocean}]{\sphinxcrossref{evaluate\_ocean}}}}
\sphinxAtStartPar
evaluate the ocean function based on the Gaussian grid of the topography

\end{description}
\end{quote}

\end{fulllineitems}



\paragraph{\sphinxstylestrong{METHODS}}
\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:id2}}\index{update\_0() (in module SL\_C0de.grid.OCEAN\_TIME\_GRID)@\spxentry{update\_0()}\spxextra{in module SL\_C0de.grid.OCEAN\_TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:SL_C0de.grid.OCEAN_TIME_GRID.update_0}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.OCEAN\_TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{update\_0}}}{\emph{\DUrole{n}{self}}}{}
\pysigstopsignatures\phantomsection\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:update-0-oce}}
\sphinxAtStartPar
The update\_0 method update the grd\_0 parameter of the object to the currend loaded grd.


\subparagraph{Attributes}
\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:id3}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}


\subparagraph{Return}
\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:return}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{evaluate\_ocean() (in module SL\_C0de.grid.OCEAN\_TIME\_GRID)@\spxentry{evaluate\_ocean()}\spxextra{in module SL\_C0de.grid.OCEAN\_TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:SL_C0de.grid.OCEAN_TIME_GRID.evaluate_ocean}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.OCEAN\_TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{evaluate\_ocean}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{topo}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:evaluate-ocean}}evaluate\_ocean method evaluate the ocean function using the topography. It create a 0\sphinxhyphen{}1 matrix wich is 1 where topo\textless{}0 and 0 where topo\textgreater{}0.  The ocean function is described in {\hyperref[\detokenize{numerical_imp:oc-func}]{\sphinxcrossref{\DUrole{std,std-ref}{ocean function}}}}.


\subparagraph{Attribute}
\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:attribute}}\begin{quote}
\begin{description}
\sphinxlineitem{topo}{[}np.array(maxdeg,maxdegx2){]}
\sphinxAtStartPar
topographic gaussian grid.

\end{description}
\end{quote}
\begin{description}
\sphinxlineitem{Returns :}
\sphinxAtStartPar
None

\end{description}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{sea\_level\_solver() (in module SL\_C0de.grid.OCEAN\_TIME\_GRID)@\spxentry{sea\_level\_solver()}\spxextra{in module SL\_C0de.grid.OCEAN\_TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:SL_C0de.grid.OCEAN_TIME_GRID.sea_level_solver}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.OCEAN\_TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{sea\_level\_solver}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{load}}, \emph{\DUrole{n}{ice\_time\_grid}}, \emph{\DUrole{n}{sed\_time\_grid}}, \emph{\DUrole{n}{love\_number}}, \emph{\DUrole{n}{TO}}, \emph{\DUrole{n}{t\_it}}, \emph{\DUrole{n}{conv\_it}}, \emph{\DUrole{n}{conv\_lim}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:sea-level-solver}}sea\_level\_solver method solve the sea level equation until. Beacause of the iterative type of the resolution of the SLE, this method define also a first guess of the Sea level at the first iteration and the first time step. This function is based on the convergence iteration for the estimation of the variability defined in {\hyperref[\detokenize{numerical_imp:conv}]{\sphinxcrossref{\DUrole{std,std-ref}{Convergence parameter}}}}.


\subparagraph{Attribute}
\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:id4}}\begin{quote}
\begin{description}
\sphinxlineitem{load}{[}{\hyperref[\detokenize{GRID_doc/LOAD_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{LOAD\_TIME\_GRID}}}} class object{]}
\sphinxAtStartPar
The load time grid as specified in the class object. This grid needs to be of the same shape (maxdeg) then the one of the current object.

\sphinxlineitem{ice\_time\_grid}{[}{\hyperref[\detokenize{GRID_doc/ICE_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{ICE\_TIME\_GRID}}}} class object{]}
\sphinxAtStartPar
The ice time grid as specified in the class object. This grid needs to be of the same shape (maxdeg) then the one of the current object.

\sphinxlineitem{sed\_time\_grid}{[}{\hyperref[\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{SEDIMENT\_TIME\_GRID}}}} class object{]}
\sphinxAtStartPar
The sediment time grid as specified in the class object. This grid needs to be of the same shape (maxdeg) then the one of the current object.

\sphinxlineitem{love\_number}{[}{\hyperref[\detokenize{love_doc:id5}]{\sphinxcrossref{\DUrole{std,std-ref}{LOVE}}}} class object {]}
\sphinxAtStartPar
The love numbers as specified in the class object. The love numbers must have been set up with the same maximm degree thne the currend object.

\sphinxlineitem{TO}{[}{\hyperref[\detokenize{spharm_doc:sphericalobject}]{\sphinxcrossref{\DUrole{std,std-ref}{sphericalobject}}}} class object{]}
\sphinxAtStartPar
The ocean contours variability area computed as a sphericalobject class computed for the previous iteration. !Trouver où définir ce calcul!.

\sphinxlineitem{t\_it}{[}int{]}
\sphinxAtStartPar
The time iteration of the current computation on wich apply the resolution of the SLE.

\sphinxlineitem{conv\_it}{[}int{]}
\sphinxAtStartPar
convergence iteration set to 0 if it’s for a simple resolution of the SLE on one time step. This is used when you are working on a topographic convergence. In the code, the first guess for the SLE will be if it’s not the first topographic convergence iteration, the guess of the previuous one.

\sphinxlineitem{conv\_lim}{[}float{]}
\sphinxAtStartPar
To stop the convergence of the solution, the conv\_lim is usually set to 10\textasciicircum{}\sphinxhyphen{}3. The number of required step is then between 13 and 7.

\end{description}
\end{quote}


\subparagraph{Return}
\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:id5}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{sea\_level\_equation() (in module SL\_C0de.grid.OCEAN\_TIME\_GRID)@\spxentry{sea\_level\_equation()}\spxextra{in module SL\_C0de.grid.OCEAN\_TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:SL_C0de.grid.OCEAN_TIME_GRID.sea_level_equation}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.OCEAN\_TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{sea\_level\_equation}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{load}}, \emph{\DUrole{n}{ice\_time\_grid}}, \emph{\DUrole{n}{sed\_time\_grid}}, \emph{\DUrole{n}{love\_number}}, \emph{\DUrole{n}{TO}}, \emph{\DUrole{n}{t\_it}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:sea-level-equation}}sea\_level\_equation method calculate the Sea level variation following the SLE. Tis function is resolving both the conservation of mass equation and the SL variation. This follows the method described in {\hyperref[\detokenize{numerical_imp:spec-sol}]{\sphinxcrossref{\DUrole{std,std-ref}{Resolution of SLE including the deconvolution}}}}.


\subparagraph{Attribute}
\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:id6}}\begin{quote}
\begin{description}
\sphinxlineitem{load}{[}{\hyperref[\detokenize{GRID_doc/LOAD_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{LOAD\_TIME\_GRID}}}} class object{]}
\sphinxAtStartPar
The load time grid as specified in the class object. This grid needs to be of the same shape (maxdeg) then the one of the current object.

\sphinxlineitem{ice\_time\_grid}{[}{\hyperref[\detokenize{GRID_doc/ICE_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{ICE\_TIME\_GRID}}}} class object{]}
\sphinxAtStartPar
The ice time grid as specified in the class object. This grid needs to be of the same shape (maxdeg) then the one of the current object.

\sphinxlineitem{sed\_time\_grid}{[}{\hyperref[\detokenize{GRID_doc/SEDIMENT_TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{SEDIMENT\_TIME\_GRID}}}} class object{]}
\sphinxAtStartPar
The sediment time grid as specified in the class object. This grid needs to be of the same shape (maxdeg) then the one of the current object.

\sphinxlineitem{love\_number}{[}{\hyperref[\detokenize{love_doc:id5}]{\sphinxcrossref{\DUrole{std,std-ref}{LOVE}}}} class object {]}
\sphinxAtStartPar
The love numbers as specified in the class object. The love numbers must have been set up with the same maximm degree thne the currend object.

\sphinxlineitem{TO}{[}{\hyperref[\detokenize{spharm_doc:sphericalobject}]{\sphinxcrossref{\DUrole{std,std-ref}{sphericalobject}}}} class object{]}
\sphinxAtStartPar
The ocean contours variability area computed as a sphericalobject class computed for the previous iteration. !Trouver où définir ce calcul!.

\sphinxlineitem{t\_it}{[}int{]}
\sphinxAtStartPar
The time iteration of the current computation on wich apply the resolution of the SLE.

\end{description}
\end{quote}


\subparagraph{Return}
\label{\detokenize{GRID_doc/OCEAN_TIME_GRID_doc:id7}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{TOPOGRAPHIC\_TIME\_GRID}
\label{\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc:topographic-time-grid}}\label{\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc::doc}}

\paragraph{\sphinxstylestrong{CLASS}}
\label{\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc:class}}\index{TOPOGRAPHIC\_TIME\_GRID (class in SL\_C0de.grid)@\spxentry{TOPOGRAPHIC\_TIME\_GRID}\spxextra{class in SL\_C0de.grid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc:SL_C0de.grid.TOPOGRAPHIC_TIME_GRID}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{SL\_C0de.grid.}}\sphinxbfcode{\sphinxupquote{TOPOGRAPHIC\_TIME\_GRID}}}{\emph{\DUrole{n}{time\_step}\DUrole{o}{=}\DUrole{default_value}{array({[}1, 2{]})}}, \emph{\DUrole{n}{maxdeg}\DUrole{o}{=}\DUrole{default_value}{64}}, \emph{\DUrole{n}{height\_time\_grid}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mass\_time\_grid}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mass\_time\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{height\_time\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{rho}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{grid\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}time\_grid\textquotesingle{}}}, \emph{\DUrole{n}{from\_file}\DUrole{o}{=}\DUrole{default_value}{(False,)}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc:id1}}TOPOGRAPHIC\_TIME\_GRID class is used to save and include all the topographic variations. This class inherits of {\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{TIME\_GRID}}}}. This class main difference with TIME\_GRID is the presence of a parameter called topo\_pres wich is the present topography. It is created using {\hyperref[\detokenize{SOLVER_doc:precomputation}]{\sphinxcrossref{\DUrole{std,std-ref}{Precomputation}}}}.


\subparagraph{Attributes}
\label{\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc:attributes}}\begin{quote}
\begin{description}
\sphinxlineitem{time\_step}{[}np.array({[}time\_step\_number,{]}){]}
\sphinxAtStartPar
This array contains the time step of the data you are importing. They will be use for temporal interpolation.

\sphinxlineitem{maxdeg}{[}int{]}
\sphinxAtStartPar
Maximum harmonic coefficient degree of the data. this define the chape of the grid and coefficient arrays

\sphinxlineitem{height\_time\_grid}{[}np.array({[}maxedg*2,maxdeg{]}){]}
\sphinxAtStartPar
This array is the height grid at each time steps defined in grid\_time\_step

\sphinxlineitem{mass\_time\_grid}{[}np.array({[}maxedg*2,maxdeg{]}){]}
\sphinxAtStartPar
This array is the mass grid at each time steps defined in grid\_time\_step

\sphinxlineitem{height\_time\_coeff}{[}np.array({[}(maxdeg+1)(maxedg+2)/2,{]}){]}
\sphinxAtStartPar
This array is the height spherical harmonic coefficient at each time steps defined in grid\_time\_step

\sphinxlineitem{mass\_time\_coeff}{[}np.array({[}(maxdeg+1)(maxedg+2)/2,{]}){]}
\sphinxAtStartPar
This array is the mass spherical harmonic coefficient at each time steps defined in grid\_time\_step

\sphinxlineitem{rho}{[}float{]}
\sphinxAtStartPar
The density of the considered layer.

\end{description}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In future development the density may vary threw space and time. We’ll have to make a variable object more then a constant density.
\end{sphinxadmonition}
\begin{description}
\sphinxlineitem{grid\_name}{[}str{]}
\sphinxAtStartPar
The name of the grid. We recommand you to choose a specific name for each grid you create. This name is used to save the grid in an nc file with {\color{red}\bfseries{}\textasciigrave{}save\textasciigrave{}\_}.

\sphinxlineitem{from\_file}{[}(bool,way){]}
\sphinxAtStartPar
This parameter define if the data are new or loaded from a previously saved model in a nc file. If the first element is False, the code will create a blank object, based on provided datas. If the first element is True, the method will get the data from the file way specified in the second element of this attribute.

\end{description}
\end{quote}


\subparagraph{Methods}
\label{\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc:methods}}\begin{quote}
\begin{description}
\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc:topo-save}]{\sphinxcrossref{\DUrole{std,std-ref}{save}}}} }
\sphinxAtStartPar
Method to save the topographic datas

\end{description}
\end{quote}

\end{fulllineitems}



\paragraph{\sphinxstylestrong{METHODS}}
\label{\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc:id2}}\index{save() (in module SL\_C0de.grid.TOPOGRAPHIC\_TIME\_GRID)@\spxentry{save()}\spxextra{in module SL\_C0de.grid.TOPOGRAPHIC\_TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc:SL_C0de.grid.TOPOGRAPHIC_TIME_GRID.save}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.TOPOGRAPHIC\_TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{save\_way}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures\phantomsection\label{\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc:topo-save}}
\sphinxAtStartPar
The save method is used to save the data of the topographic grid. Particularity of the topography is the present day topography used in the code to converge toward it. The function save is. Otherwise this method use the super method \DUrole{xref,std,std-ref}{save} to save the rest of the data.


\subparagraph{Attributes}
\label{\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc:id3}}\begin{quote}
\begin{description}
\sphinxlineitem{save\_way :str}
\sphinxAtStartPar
The way where the nc file is saved. Default value is the current file (an empty str).

\end{description}
\end{quote}


\subparagraph{Return}
\label{\detokenize{GRID_doc/TOPOGRAPHIC_TIME_GRID_doc:return}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}


\sphinxstepscope


\subsubsection{LOAD\_TIME\_GRID}
\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:load-time-grid}}\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc::doc}}

\paragraph{\sphinxstylestrong{CLASS}}
\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:class}}\index{LOAD\_TIME\_GRID (class in SL\_C0de.grid)@\spxentry{LOAD\_TIME\_GRID}\spxextra{class in SL\_C0de.grid}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:SL_C0de.grid.LOAD_TIME_GRID}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{SL\_C0de.grid.}}\sphinxbfcode{\sphinxupquote{LOAD\_TIME\_GRID}}}{\emph{\DUrole{n}{sdelL}\DUrole{o}{=}\DUrole{default_value}{array({[}{]}, dtype=float64)}}, \emph{\DUrole{n}{beta\_l}\DUrole{o}{=}\DUrole{default_value}{array({[}{]}, dtype=float64)}}, \emph{\DUrole{n}{E}\DUrole{o}{=}\DUrole{default_value}{array({[}{]}, dtype=float64)}}, \emph{\DUrole{n}{a}\DUrole{o}{=}\DUrole{default_value}{7371000}}, \emph{\DUrole{n}{Me}\DUrole{o}{=}\DUrole{default_value}{5000}}, \emph{\DUrole{n}{time\_step}\DUrole{o}{=}\DUrole{default_value}{array({[}1, 2{]})}}, \emph{\DUrole{n}{maxdeg}\DUrole{o}{=}\DUrole{default_value}{64}}, \emph{\DUrole{n}{height\_time\_grid}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mass\_time\_grid}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{mass\_time\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{height\_time\_coeff}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{rho}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{grid\_name}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}time\_grid\textquotesingle{}}}, \emph{\DUrole{n}{from\_file}\DUrole{o}{=}\DUrole{default_value}{(False,)}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:id1}}LOAD\_TIME\_GRID class is used to save and include all the topographic variations. This class inherits of {\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:id1}]{\sphinxcrossref{\DUrole{std,std-ref}{TIME\_GRID}}}} and \DUrole{xref,std,std-ref}{LOAD}.


\subparagraph{Attributes}
\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:attributes}}\begin{quote}
\begin{description}
\sphinxlineitem{sdelL}{[}np.array({[}time\_step\_number,maxdeg,maxdegx2{]}){]}
\sphinxAtStartPar
The load variation grid used to compute earth vertical motion.

\sphinxlineitem{betal}{[}np.array({[}time\_step\_number,time\_step\_number,maxdeg{]}){]}
\sphinxAtStartPar
The beta love number as described in {\hyperref[\detokenize{Theory:geoid-ground-variation-theory}]{\sphinxcrossref{\DUrole{std,std-ref}{Variation of geoïd and ground Equations}}}} section. There calculated in the {\hyperref[\detokenize{love_doc:id5}]{\sphinxcrossref{\DUrole{std,std-ref}{LOVE}}}} class.

\sphinxlineitem{E}{[}np.array({[}(maxdeg+1)(maxdeg+2)/2,{]}){]}
\sphinxAtStartPar
The elastic component of the earth as love numbers computed form {\hyperref[\detokenize{love_doc:id5}]{\sphinxcrossref{\DUrole{std,std-ref}{LOVE}}}} class.

\sphinxlineitem{a}{[}float{]}
\sphinxAtStartPar
The earth radius in meter, set by default to 7371000 meters.

\sphinxlineitem{Me}{[}float{]}
\sphinxAtStartPar
The earth mass in set by default to 5000.

\sphinxlineitem{time\_step}{[}np.array({[}time\_step\_number,{]}){]}
\sphinxAtStartPar
This array contains the time step of the data you are importing. They will be use for temporal interpolation.

\sphinxlineitem{maxdeg}{[}int{]}
\sphinxAtStartPar
Maximum harmonic coefficient degree of the data. this define the chape of the grid and coefficient arrays

\sphinxlineitem{height\_time\_grid}{[}np.array({[}maxedg*2,maxdeg{]}){]}
\sphinxAtStartPar
This array is the height grid at each time steps defined in grid\_time\_step

\sphinxlineitem{mass\_time\_grid}{[}np.array({[}maxedg*2,maxdeg{]}){]}
\sphinxAtStartPar
This array is the mass grid at each time steps defined in grid\_time\_step

\sphinxlineitem{height\_time\_coeff}{[}np.array({[}(maxdeg+1)(maxedg+2)/2,{]}){]}
\sphinxAtStartPar
This array is the height spherical harmonic coefficient at each time steps defined in grid\_time\_step

\sphinxlineitem{mass\_time\_coeff}{[}np.array({[}(maxdeg+1)(maxedg+2)/2,{]}){]}
\sphinxAtStartPar
This array is the mass spherical harmonic coefficient at each time steps defined in grid\_time\_step

\sphinxlineitem{rho}{[}float{]}
\sphinxAtStartPar
The density of the considered layer.

\sphinxlineitem{grid\_name}{[}str{]}
\sphinxAtStartPar
The name of the grid. We recommand you to choose a specific name for each grid you create. This name is used to save the grid in an nc file with {\color{red}\bfseries{}\textasciigrave{}save\textasciigrave{}\_}.

\sphinxlineitem{from\_file}{[}(bool,way){]}
\sphinxAtStartPar
This parameter define if the data are new or loaded from a previously saved model in a nc file. If the first element is False, the code will create a blank object, based on provided datas. If the first element is True, the method will get the data from the file way specified in the second element of this attribute.

\end{description}
\end{quote}


\subparagraph{Methods}
\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:methods}}\begin{quote}
\begin{description}
\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/LOAD_TIME_GRID_doc:calc-viscuous}]{\sphinxcrossref{calc\_viscuous}}}:}
\sphinxAtStartPar
Compute the viscous motion of the geoïd and ground for one time step.

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/LOAD_TIME_GRID_doc:calc-viscuous-time}]{\sphinxcrossref{calc\_viscuous\_time}}} :}
\sphinxAtStartPar
Compute the viscous ground motion of the earth on all time steps.

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/LOAD_TIME_GRID_doc:calc-elastic-time}]{\sphinxcrossref{calc\_elastic\_time}}} :}
\sphinxAtStartPar
Compute the elastic ground motion of the earth on all time steps.

\sphinxlineitem{{\hyperref[\detokenize{GRID_doc/LOAD_TIME_GRID_doc:load-save}]{\sphinxcrossref{\DUrole{std,std-ref}{save}}}} :}
\sphinxAtStartPar
Save the load data

\end{description}
\end{quote}

\end{fulllineitems}



\paragraph{\sphinxstylestrong{Methods}}
\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:id2}}\index{calc\_viscuous() (in module SL\_C0de.grid.LOAD\_TIME\_GRID)@\spxentry{calc\_viscuous()}\spxextra{in module SL\_C0de.grid.LOAD\_TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:SL_C0de.grid.LOAD_TIME_GRID.calc_viscuous}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.LOAD\_TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{calc\_viscuous}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{sdelL}}, \emph{\DUrole{n}{beta}}, \emph{\DUrole{n}{t\_it}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:calc-viscuous}}calc\_viscuous method is used to calculate the ground and geoïd deformation based on viscuous love numbers.


\subparagraph{Attribute}
\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:attribute}}\begin{quote}
\begin{description}
\sphinxlineitem{sdelL}{[}np.array({[}t\_it,(maxdeg+1)(maxdeg+20/2){]}){]}
\sphinxAtStartPar
The load grid used to estimate the ground vertical mouvement. This include all previous loading history because of the viscous comportment of earth.

\sphinxlineitem{beta}{[}np.array({[}time\_step\_number,time\_step\_number,(maxdeg+1)(maxdeg+2)/2{]}){]}
\sphinxAtStartPar
The beta love numbers used to compute the earth deformation to include the viscous part. These love numbers are particularly heavy in the memory due to the representation of the time.

\sphinxlineitem{t\_it}{[}int{]}
\sphinxAtStartPar
The time iteration at wich the computation is performed.

\end{description}
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{calc\_viscuous\_time() (in module SL\_C0de.grid.LOAD\_TIME\_GRID)@\spxentry{calc\_viscuous\_time()}\spxextra{in module SL\_C0de.grid.LOAD\_TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:SL_C0de.grid.LOAD_TIME_GRID.calc_viscuous_time}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.LOAD\_TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{calc\_viscuous\_time}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{backend}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:calc-viscuous-time}}calc\_viscuous\_time method compute the vicuous vertical ground motion. This method call the \DUrole{xref,std,std-ref}{LOAD} method for this.


\subparagraph{Attribute}
\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:id3}}\begin{quote}
\begin{description}
\sphinxlineitem{backend}{[}bool{]}
\sphinxAtStartPar
Specifie if the method give backend (True) or not (False). Default is False.

\end{description}
\end{quote}


\subparagraph{Return}
\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:return}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{calc\_elastic\_time() (in module SL\_C0de.grid.LOAD\_TIME\_GRID)@\spxentry{calc\_elastic\_time()}\spxextra{in module SL\_C0de.grid.LOAD\_TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:SL_C0de.grid.LOAD_TIME_GRID.calc_elastic_time}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.LOAD\_TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{calc\_elastic\_time}}}{\emph{\DUrole{n}{self}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:calc-elastic-time}}calc\_elastic\_time method compute the elactic vertical ground motion. This method call the \DUrole{xref,std,std-ref}{LOAD} method for this.


\subparagraph{Attribute}
\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:id4}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}


\subparagraph{Return}
\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:id5}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{save() (in module SL\_C0de.grid.LOAD\_TIME\_GRID)@\spxentry{save()}\spxextra{in module SL\_C0de.grid.LOAD\_TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:SL_C0de.grid.LOAD_TIME_GRID.save}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.LOAD\_TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{save\_way}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}\textquotesingle{}}}}{}
\pysigstopsignatures\phantomsection\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:load-save}}
\sphinxAtStartPar
The save method is used to save the data from the class. It is based on the inherited {\hyperref[\detokenize{GRID_doc/TIME_GRID_doc:save}]{\sphinxcrossref{\DUrole{std,std-ref}{save}}}} method. Because of the particularity of this TIME\_GRID, we had to save the new parameters, and calculated data. This function save for each data the real and complex part of the data due to the nc file particularity. The saved data are, The load (load), the viscuous groud motion (viscous\_deformation), the elastic ground motion (elastic\_deformation), the elastic love numbers (elastic\_love), earth radius (a), earth mass (Me).


\subparagraph{Attribute}
\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:id6}}\begin{quote}
\begin{description}
\sphinxlineitem{save\_way}{[}str{]}
\sphinxAtStartPar
file path to where the grid will be saved.

\end{description}
\end{quote}


\subparagraph{Return}
\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:id7}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{clean\_memory() (in module SL\_C0de.grid.LOAD\_TIME\_GRID)@\spxentry{clean\_memory()}\spxextra{in module SL\_C0de.grid.LOAD\_TIME\_GRID}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{GRID_doc/LOAD_TIME_GRID_doc:SL_C0de.grid.LOAD_TIME_GRID.clean_memory}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.grid.LOAD\_TIME\_GRID.}}\sphinxbfcode{\sphinxupquote{clean\_memory}}}{\emph{\DUrole{n}{self}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method is used to clean the memory to avoïd over charging RAM.

\end{fulllineitems}


\sphinxstepscope


\subsection{love}
\label{\detokenize{love_doc:love}}\label{\detokenize{love_doc::doc}}
\sphinxAtStartPar
This module is used to manage the love numbers for the earth deformation calculation.


\subsubsection{\sphinxstylestrong{Functions}}
\label{\detokenize{love_doc:functions}}\index{love\_lm() (in module SL\_C0de.love)@\spxentry{love\_lm()}\spxextra{in module SL\_C0de.love}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{love_doc:SL_C0de.love.love_lm}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.love.}}\sphinxbfcode{\sphinxupquote{love\_lm}}}{\emph{\DUrole{n}{num}}, \emph{\DUrole{n}{maxdeg}}}{}
\pysigstopsignatures
\sphinxAtStartPar
the \phantomsection\label{\detokenize{love_doc:love-lm}}love\_lm funtion get from love numbers the h\_lm spherical coefficient.


\paragraph{Attribute}
\label{\detokenize{love_doc:attribute}}\begin{quote}
\begin{description}
\sphinxlineitem{num}{[}np.array({[}n,{]}) {]}
\sphinxAtStartPar
Love number coefficient of the size of the entry file

\sphinxlineitem{maxdeg}{[}int{]}
\sphinxAtStartPar
The maximum harmonic coefficient degree.

\end{description}
\end{quote}


\paragraph{Returns}
\label{\detokenize{love_doc:returns}}\begin{quote}
\begin{description}
\sphinxlineitem{h\_lm}{[}np.array({[}(maxdeg+1)(maxdeg+2)/2,{]}){]}
\sphinxAtStartPar
Array of the love number repeated on harmonic degree orders.

\end{description}
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{get\_tlm() (in module SL\_C0de.love)@\spxentry{get\_tlm()}\spxextra{in module SL\_C0de.love}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{love_doc:SL_C0de.love.get_tlm}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.love.}}\sphinxbfcode{\sphinxupquote{get\_tlm}}}{\emph{\DUrole{n}{maxdeg}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{Me}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{love_doc:get-lm}}get\_lm function generate the T spherical harmonic coefficient as defined in {\hyperref[\detokenize{Theory:t-definition}]{\sphinxcrossref{\DUrole{std,std-ref}{Theory}}}}.


\paragraph{Attribute}
\label{\detokenize{love_doc:id1}}\begin{quote}
\begin{description}
\sphinxlineitem{maxdeg}{[}int{]}
\sphinxAtStartPar
maximum degree of spherical harmonic defined in the model parameters.

\sphinxlineitem{a}{[}float{]}
\sphinxAtStartPar
The earth radius in meters.

\sphinxlineitem{Me}{[}float{]}
\sphinxAtStartPar
The earth mass.

\end{description}
\end{quote}


\paragraph{Returns}
\label{\detokenize{love_doc:id2}}\begin{quote}
\begin{description}
\sphinxlineitem{T\_lm}{[}np.array({[}(maxdeg+1)(maxdeg+2)/2{]}){]}
\sphinxAtStartPar
The T harmonic coefficient

\end{description}
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip

\index{calc\_beta\_counter() (in module SL\_C0de.love)@\spxentry{calc\_beta\_counter()}\spxextra{in module SL\_C0de.love}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{love_doc:SL_C0de.love.calc_beta_counter}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.love.}}\sphinxbfcode{\sphinxupquote{calc\_beta\_counter}}}{\emph{\DUrole{n}{self}}, \emph{\DUrole{n}{maxdeg}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{love_doc:calc-beta-counter}}calc\_beta\_counter define the degree of the spherical harmonic for each beta coefficient


\paragraph{Attribute}
\label{\detokenize{love_doc:id3}}\begin{quote}
\begin{description}
\sphinxlineitem{self}{[}{\hyperref[\detokenize{love_doc:id5}]{\sphinxcrossref{\DUrole{std,std-ref}{LOVE}}}} class object{]}
\sphinxAtStartPar
The LOVE class object on wich the betacounter is calculated

\sphinxlineitem{maxdeg}{[}int{]}
\sphinxAtStartPar
maximum spherical harmonic coefficient

\end{description}
\end{quote}


\paragraph{Returns}
\label{\detokenize{love_doc:id4}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\bigskip\hrule\bigskip



\subsubsection{\sphinxstylestrong{CLASS}}
\label{\detokenize{love_doc:class}}\index{LOVE (class in SL\_C0de.love)@\spxentry{LOVE}\spxextra{class in SL\_C0de.love}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{love_doc:SL_C0de.love.LOVE}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{SL\_C0de.love.}}\sphinxbfcode{\sphinxupquote{LOVE}}}{\emph{\DUrole{n}{maxdeg}}, \emph{\DUrole{n}{way}}, \emph{\DUrole{n}{time\_step}}, \emph{\DUrole{n}{a}}, \emph{\DUrole{n}{Me}}, \emph{\DUrole{n}{type}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}time\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{love_doc:id5}}LOVE class is used to keep the love numbers values and prepare them for the computation of geoïd and ground vertical motion. The love number are calculted and loaded from a file as described in {\hyperref[\detokenize{love_doc:id5}]{\sphinxcrossref{\DUrole{std,std-ref}{Implementation of Love numbers}}}}. This function also include the possibility to compute the love numbers from normal modes love numbers parameters.


\paragraph{Attributes}
\label{\detokenize{love_doc:attributes}}\begin{quote}
\begin{description}
\sphinxlineitem{maxedeg}{[}int{]}
\sphinxAtStartPar
The spherical harmonic maximum degree.

\sphinxlineitem{way}{[}str{]}
\sphinxAtStartPar
The file path to the ALMA output file. This file must follow the described pattern in …

\sphinxlineitem{time\_step}{[}np.array({[}time\_step\_number,{]}){]}
\sphinxAtStartPar
The time step of the model, used to prepare the viscuous love numbers.

\sphinxlineitem{a}{[}float{]}
\sphinxAtStartPar
The earth radius in meter.

\sphinxlineitem{Me}{[}float{]}
\sphinxAtStartPar
The earth mass.

\sphinxlineitem{type}{[}str{]}
\sphinxAtStartPar
The type of love number in input. could be ‘time’ or ‘normal, where ‘time’ is for love numbers from ALMA3 code and ‘normal’ is for love number in normale mode from MIT serveur. Default is ‘time’.

\end{description}
\end{quote}


\paragraph{Methods}
\label{\detokenize{love_doc:methods}}\begin{quote}
\begin{description}
\sphinxlineitem{{\color{red}\bfseries{}\textasciigrave{}calc\_beta\_G\textasciigrave{}\_} :}
\sphinxAtStartPar
This method is used to calculate the beta love numbers associated to the geoïd.

\sphinxlineitem{{\color{red}\bfseries{}\textasciigrave{}calc\_beta\_R\textasciigrave{}\_} :}
\sphinxAtStartPar
This method is used to calculate the beta love numbers associated to the ground motion.

\sphinxlineitem{{\color{red}\bfseries{}\textasciigrave{}calc\_beta\textasciigrave{}\_} :}
\sphinxAtStartPar
This method is used to calculate the beta love number associated to both geoïd and ground.

\sphinxlineitem{{\hyperref[\detokenize{love_doc:clean-memory}]{\sphinxcrossref{clean\_memory}}} :}
\sphinxAtStartPar
This method is used to clean the memory of your computer.

\end{description}
\end{quote}

\end{fulllineitems}



\subsubsection{\sphinxstylestrong{Methods}}
\label{\detokenize{love_doc:id6}}

\bigskip\hrule\bigskip



\bigskip\hrule\bigskip



\bigskip\hrule\bigskip

\index{clean\_memory() (in module SL\_C0de.love.LOVE)@\spxentry{clean\_memory()}\spxextra{in module SL\_C0de.love.LOVE}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{love_doc:SL_C0de.love.LOVE.clean_memory}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{SL\_C0de.love.LOVE.}}\sphinxbfcode{\sphinxupquote{clean\_memory}}}{\emph{\DUrole{n}{self}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The \phantomsection\label{\detokenize{love_doc:clean-memory}}clean\_memory method can be used to araise the beta\_l, beta\_R and beta\_G to avoid memory issues.


\paragraph{Attribute}
\label{\detokenize{love_doc:id7}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}


\paragraph{Return}
\label{\detokenize{love_doc:return}}\begin{quote}

\sphinxAtStartPar
None
\end{quote}

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}

\begin{sphinxthebibliography}{1}
\bibitem[1]{index:id3}
\sphinxAtStartPar
A. V. Dalca, K. L. Ferrier, J. X. Mitrovica, J. T. Perron, G. A. Milne, and J. R. Creveling. On postglacial sea level—III. Incorporating sediment redistribution. \sphinxstyleemphasis{Geophysical Journal International}, 194(1):45\textendash{}60, July 2013. \sphinxhref{https://doi.org/10.1093/gji/ggt089}{doi:10.1093/gji/ggt089}.
\bibitem[2]{index:id4}
\sphinxAtStartPar
Ken L. Ferrier, Jacqueline Austermann, Jerry X. Mitrovica, and Tamara Pico. Incorporating sediment compaction into a gravitationally self\sphinxhyphen{}consistent model for ice age sea\sphinxhyphen{}level change. \sphinxstyleemphasis{Geophysical Journal International}, 211(1):663\textendash{}672, October 2017. \sphinxhref{https://doi.org/10.1093/gji/ggx293}{doi:10.1093/gji/ggx293}.
\bibitem[3]{index:id5}
\sphinxAtStartPar
Roblyn A. Kendall, Jerry X. Mitrovica, and Glenn A. Milne. On post\sphinxhyphen{}glacial sea level \sphinxhyphen{} II. Numerical formulation and comparative results on spherically symmetric models. \sphinxstyleemphasis{Geophysical Journal International}, 161(3):679\textendash{}706, June 2005. \sphinxhref{https://doi.org/10.1111/j.1365-246X.2005.02553.x}{doi:10.1111/j.1365\sphinxhyphen{}246X.2005.02553.x}.
\bibitem[4]{index:id6}
\sphinxAtStartPar
Augustus Love. \sphinxstyleemphasis{A Treatise on the Mathematical Theory of Elasticity}. Volume 1. Cambridge, 1892.
\bibitem[5]{index:id7}
\sphinxAtStartPar
D Melini, C Saliby, and G Spada. On computing viscoelastic Love numbers for general planetary models: the ALMA3 code. \sphinxstyleemphasis{Geophysical Journal International}, 231(3):1502\textendash{}1517, August 2022. \sphinxhref{https://doi.org/10.1093/gji/ggac263}{doi:10.1093/gji/ggac263}.
\bibitem[6]{index:id8}
\sphinxAtStartPar
Glenn A. Milne and Jerry X. Mitrovica. Postglacial sea\sphinxhyphen{}level change on a rotating Earth. \sphinxstyleemphasis{Geophysical Journal International}, 133(1):1\textendash{}19, April 1998. \sphinxhref{https://doi.org/10.1046/j.1365-246X.1998.1331455.x}{doi:10.1046/j.1365\sphinxhyphen{}246X.1998.1331455.x}.
\bibitem[7]{index:id9}
\sphinxAtStartPar
J. X. Mitrovica and W. R. Peltier. Pleistocene deglaciation and the global gravity field. \sphinxstyleemphasis{Journal of Geophysical Research: Solid Earth}, 94(B10):13651\textendash{}13671, October 1989. \sphinxhref{https://doi.org/10.1029/JB094iB10p13651}{doi:10.1029/JB094iB10p13651}.
\bibitem[8]{index:id10}
\sphinxAtStartPar
W. R. Peltier. The impulse response of a Maxwell Earth. \sphinxstyleemphasis{Reviews of Geophysics}, 12(4):649, 1974. \sphinxhref{https://doi.org/10.1029/RG012i004p00649}{doi:10.1029/RG012i004p00649}.
\bibitem[9]{index:id11}
\sphinxAtStartPar
W. R. Peltier, D. F. Argus, and R. Drummond. Space geodesy constrains ice age terminal deglaciation: The global ICE\sphinxhyphen{}6G\_C (VM5a) model: Global Glacial Isostatic Adjustment. \sphinxstyleemphasis{Journal of Geophysical Research: Solid Earth}, 120(1):450\textendash{}487, January 2015. \sphinxhref{https://doi.org/10.1002/2014JB011176}{doi:10.1002/2014JB011176}.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}